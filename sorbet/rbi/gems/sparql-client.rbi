# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sparql-client/all/sparql-client.rbi
#
# sparql-client-3.1.0

module SPARQL
end
class SPARQL::Client
  def ask(*args, **options); end
  def call_query_method(meth, *args, **options); end
  def clear(what, *arguments); end
  def clear_graph(graph_uri, **options); end
  def close; end
  def construct(*args, **options); end
  def delete_data(data, **options); end
  def delete_insert(delete_graph, insert_graph = nil, where_graph = nil, **options); end
  def describe(*args, **options); end
  def headers; end
  def http_klass(scheme); end
  def initialize(url, **options, &block); end
  def insert_data(data, **options); end
  def inspect!; end
  def inspect; end
  def make_get_request(query, headers = nil); end
  def make_post_request(query, headers = nil); end
  def nodes; end
  def options; end
  def parse_rdf_serialization(response, **options); end
  def parse_response(response, **options); end
  def query(query, **options); end
  def request(query, headers = nil, &block); end
  def request_method(query); end
  def response(query, **options); end
  def select(*args, **options); end
  def self.parse_csv_bindings(csv, nodes = nil); end
  def self.parse_json_bindings(json, nodes = nil); end
  def self.parse_json_value(value, nodes = nil); end
  def self.parse_tsv_bindings(tsv, nodes = nil); end
  def self.parse_xml_bindings(xml, nodes = nil); end
  def self.parse_xml_value(value, nodes = nil); end
  def self.serialize_patterns(patterns, use_vars = nil); end
  def self.serialize_predicate(value, rdepth = nil); end
  def self.serialize_uri(uri); end
  def self.serialize_value(value, use_vars = nil); end
  def set_url_default_graph(url); end
  def update(query, **options); end
  def url; end
end
class SPARQL::Client::ClientError < StandardError
end
class SPARQL::Client::MalformedQuery < SPARQL::Client::ClientError
end
class SPARQL::Client::ServerError < StandardError
end
class SPARQL::Client::QueryElement
  def elements; end
  def initialize(*args); end
  def to_s; end
end
class SPARQL::Client::Query < RDF::Query
  def asc(var); end
  def ask; end
  def build_patterns(patterns); end
  def construct(*patterns); end
  def desc(var); end
  def describe(*variables); end
  def distinct(state = nil); end
  def each_solution(&block); end
  def each_statement(&block); end
  def execute; end
  def expects_statements?; end
  def false?; end
  def filter(string); end
  def form; end
  def from(uri); end
  def graph(graph_uri_or_var); end
  def group(*variables); end
  def group_by(*variables); end
  def initialize(form = nil, **options, &block); end
  def inspect!; end
  def inspect; end
  def limit(length); end
  def minus(*patterns, &block); end
  def offset(start); end
  def optional(*patterns, &block); end
  def options; end
  def order(*variables); end
  def order_by(*variables); end
  def prefix(val); end
  def reduced(state = nil); end
  def result; end
  def select(*variables); end
  def self.ask(**options); end
  def self.construct(*patterns, **options); end
  def self.describe(*variables, **options); end
  def self.select(*variables, **options); end
  def slice(start, length); end
  def solutions; end
  def to_s; end
  def to_s_ggp; end
  def true?; end
  def union(*patterns, &block); end
  def values(*args); end
  def where(*patterns_queries, &block); end
  def whether(*patterns_queries, &block); end
end
class SPARQL::Client::Query::WhereDecorator < SimpleDelegator
  def select(*variables); end
end
class SPARQL::Client::Query::Filter < SPARQL::Client::QueryElement
  def initialize(*args); end
  def to_s; end
end
class SPARQL::Client::Repository < RDF::Repository
  def clear_statements; end
  def client; end
  def count; end
  def delete(*statements); end
  def delete_statements(statements); end
  def each(&block); end
  def each_object(&block); end
  def each_predicate(&block); end
  def each_statement(&block); end
  def each_subject(&block); end
  def empty?; end
  def has_object?(object); end
  def has_predicate?(predicate); end
  def has_statement?(statement); end
  def has_subject?(subject); end
  def has_triple?(triple); end
  def initialize(uri: nil, **options, &block); end
  def insert_statement(statement); end
  def insert_statements(statements); end
  def length; end
  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
  def size; end
  def supports?(feature); end
  def update_client; end
  def writable?; end
end
module SPARQL::Client::Update
  def self.clear(*arguments, **options); end
  def self.create(*arguments, **options); end
  def self.delete_data(*arguments, **options); end
  def self.drop(*arguments, **options); end
  def self.insert_data(*arguments, **options); end
  def self.load(*arguments, **options); end
end
class SPARQL::Client::Update::Operation
  def expects_statements?; end
  def initialize(*arguments, **options); end
  def options; end
  def silent; end
end
class SPARQL::Client::Update::InsertData < SPARQL::Client::Update::Operation
  def data; end
  def expects_statements?; end
  def graph(uri); end
  def initialize(data, **options); end
  def to_s; end
end
class SPARQL::Client::Update::DeleteData < SPARQL::Client::Update::Operation
  def data; end
  def graph(uri); end
  def initialize(data, **options); end
  def to_s; end
end
class SPARQL::Client::Update::DeleteInsert < SPARQL::Client::Update::Operation
  def delete_graph; end
  def graph(uri); end
  def initialize(_delete_graph, _insert_graph = nil, _where_graph = nil, **options); end
  def insert_graph; end
  def to_s; end
  def where_graph; end
end
class SPARQL::Client::Update::Load < SPARQL::Client::Update::Operation
  def from; end
  def initialize(from, into: nil, **options); end
  def into(uri); end
  def to_s; end
end
class SPARQL::Client::Update::Clear < SPARQL::Client::Update::Operation
  def all; end
  def default; end
  def expects_statements?; end
  def graph(uri); end
  def named; end
  def to_s; end
  def uri; end
end
class SPARQL::Client::Update::Create < SPARQL::Client::Update::Operation
  def initialize(uri, **options); end
  def to_s; end
  def uri; end
end
class SPARQL::Client::Update::Drop < SPARQL::Client::Update::Clear
  def to_s; end
end
class SPARQL::Client::Update::Copy < SPARQL::Client::Update::Operation
  def to_s; end
end
class SPARQL::Client::Update::Move < SPARQL::Client::Update::Operation
  def to_s; end
end
class SPARQL::Client::Update::Add < SPARQL::Client::Update::Operation
  def to_s; end
end
module SPARQL::Client::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
