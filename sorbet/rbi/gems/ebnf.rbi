# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ebnf/all/ebnf.rbi
#
# ebnf-2.1.1

module EBNF
  def self.parse(input, **options); end
end
module EBNF::BNF
  def make_bnf; end
end
module EBNF::LL1
  def branch; end
  def build_tables; end
  def cleanup; end
  def do_production(lhs); end
  def first; end
  def first_follow(*starts); end
  def follow; end
  def outputTable(io, name, table, indent = nil); end
  def pass; end
  def start; end
  def terminals; end
  def to_ruby_ll1(output, **options); end
end
module EBNF::Native
  def alt(s); end
  def diff(s); end
  def eachRule(scanner); end
  def expression(s); end
  def postfix(s); end
  def primary(s); end
  def ruleParts(rule); end
  def seq(s); end
  def terminal(s); end
end
module EBNF::PEG
  def make_peg; end
  def to_ruby_peg(output, **options); end
end
class EBNF::Base
  def ast; end
  def debug(*args, **options); end
  def depth; end
  def dup; end
  def each(kind, &block); end
  def error(*args, **options); end
  def errors; end
  def errors=(arg0); end
  def find_rule(sym); end
  def initialize(input, format: nil, **options); end
  def progress(*args, **options); end
  def renumber!; end
  def to_html(format: nil); end
  def to_ruby(output = nil, grammarFile: nil, mod_name: nil, **options); end
  def to_s(format: nil); end
  def to_sxp; end
  def to_ttl(prefix = nil, ns = nil); end
  def valid?; end
  def validate!; end
  include EBNF::BNF
  include EBNF::LL1
  include EBNF::Native
  include EBNF::PEG
end
class EBNF::LL1::Lexer
  def each(&block); end
  def each_token(&block); end
  def first(*types); end
  def initialize(input = nil, terminals = nil, **options); end
  def input; end
  def input=(arg0); end
  def lineno; end
  def match_token(*types); end
  def options; end
  def recover(*types); end
  def scanner; end
  def self.tokenize(input, terminals, **options, &block); end
  def self.unescape_codepoints(string); end
  def self.unescape_string(input); end
  def shift; end
  def skip_whitespace; end
  def token(type, value, **options); end
  def valid?; end
  def whitespace; end
  include Enumerable
end
class EBNF::LL1::Lexer::Terminal
  def ==(other); end
  def canonicalize(value); end
  def initialize(type, regexp, **options); end
  def partial_regexp; end
  def regexp; end
  def type; end
  def unescape(string); end
end
class EBNF::LL1::Lexer::Token
  def ===(value); end
  def [](key); end
  def initialize(type, value, **options); end
  def inspect; end
  def lineno; end
  def options; end
  def representation; end
  def to_a; end
  def to_hash; end
  def to_s; end
  def type; end
  def value; end
end
class EBNF::LL1::Lexer::Error < StandardError
  def initialize(message, **options); end
  def input; end
  def lineno; end
  def token; end
end
module EBNF::LL1::Parser
  def accept(type_or_value); end
  def add_prod_data(sym, *values); end
  def add_prod_datum(sym, values); end
  def debug(*args, &block); end
  def depth; end
  def error(node, message, **options); end
  def first_include?(production, token); end
  def follow_include?(production, token); end
  def get_token(recover = nil); end
  def lineno; end
  def onFinish; end
  def onStart(prod); end
  def onTerminal(prod, token); end
  def parse(input = nil, start = nil, **options, &block); end
  def prod_data; end
  def progress(node, *args, &block); end
  def self.included(base); end
  def warn(node, message, **options); end
end
module EBNF::LL1::Parser::ClassMethods
  def eval_with_binding(object); end
  def method_missing(method, *args, &block); end
  def patterns; end
  def production(term, &block); end
  def production_handlers; end
  def start_handlers; end
  def start_production(term, &block); end
  def terminal(term, regexp, **options, &block); end
  def terminal_handlers; end
end
class EBNF::LL1::Parser::Error < StandardError
  def initialize(message, **options); end
  def lineno; end
  def production; end
  def token; end
end
class EBNF::LL1::Scanner < StringScanner
  def encode_utf8(string); end
  def ensure_buffer_full; end
  def eos?; end
  def feed_me; end
  def initialize(input, **options); end
  def input; end
  def lineno; end
  def lineno=(arg0); end
  def rest; end
  def scan(pattern); end
  def scan_until(pattern); end
  def skip(pattern); end
  def skip_until(pattern); end
  def terminate; end
  def unscan; end
end
class EBNF::Rule
  def <=>(other); end
  def ==(other); end
  def add_first(terminals); end
  def add_follow(terminals); end
  def alt?; end
  def build(expr, kind: nil, cleanup: nil, **options); end
  def cclass(txt); end
  def cleanup; end
  def cleanup=(arg0); end
  def comp; end
  def comp=(arg0); end
  def eql?(other); end
  def expr; end
  def expr=(arg0); end
  def first; end
  def first_includes_eps?; end
  def follow; end
  def for_sxp; end
  def id; end
  def id=(arg0); end
  def initialize(sym, id, expr, kind: nil, ebnf: nil, first: nil, follow: nil, start: nil, top_rule: nil, cleanup: nil); end
  def inspect; end
  def kind; end
  def kind=(arg0); end
  def make_sym_id(variation = nil); end
  def non_terminals(ast, expr = nil); end
  def orig; end
  def orig=(arg0); end
  def pass?; end
  def rule?; end
  def self.from_sxp(sxp); end
  def seq?; end
  def start; end
  def start=(arg0); end
  def starts_with?(sym); end
  def sym; end
  def sym=(arg0); end
  def symbols(expr = nil); end
  def terminal?; end
  def terminals(ast, expr = nil); end
  def to_bnf; end
  def to_peg; end
  def to_regexp; end
  def to_ruby; end
  def to_s; end
  def to_sxp; end
  def to_ttl; end
  def translate_codepoints(str); end
  def ttl_expr(expr, pfx, depth, is_obj = nil); end
  def valid?(ast); end
  def validate!(ast, expr = nil); end
end
module EBNF::PEG::Rule
  def eat_whitespace(input); end
  def parse(input); end
  def parser; end
  def parser=(arg0); end
  def rept(input, min, max, prod); end
end
module EBNFMeta
end
module EBNF::PEG::Parser
  def clear_packrat; end
  def debug(*args, &block); end
  def depth; end
  def error(node, message, **options); end
  def find_rule(sym); end
  def find_terminal_regexp(sym); end
  def onFinish(result); end
  def onStart(prod); end
  def onTerminal(prod, value); end
  def packrat; end
  def parse(input = nil, start = nil, rules = nil, **options, &block); end
  def prod_data; end
  def progress(node, *args, &block); end
  def scanner; end
  def self.included(base); end
  def update_furthest_failure(pos, lineno, token); end
  def warn(node, message, **options); end
  def whitespace; end
end
module EBNF::PEG::Parser::ClassMethods
  def eval_with_binding(object); end
  def method_missing(method, *args, &block); end
  def production(term, clear_packrat: nil, &block); end
  def production_handlers; end
  def start_handlers; end
  def start_options; end
  def start_production(term, **options, &block); end
  def terminal(term, regexp = nil, **options, &block); end
  def terminal_handlers; end
  def terminal_regexps; end
end
class Anonymous_Struct_479 < Struct
  def expecting; end
  def expecting=(_); end
  def lineno; end
  def lineno=(_); end
  def pos; end
  def pos=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class EBNF::PEG::Parser::Unmatched < Anonymous_Struct_479
  def to_s; end
end
class EBNF::PEG::Parser::Error < StandardError
  def initialize(message, **options); end
  def lineno; end
  def production; end
  def rest; end
end
module EBNF::Terminals
end
class EBNF::Parser
  def ast; end
  def initialize(input, **options, &block); end
  extend EBNF::PEG::Parser::ClassMethods
  include EBNF::PEG::Parser
  include EBNF::Terminals
end
class EBNF::Writer
  def escape_abnf_hex(u); end
  def escape_ebnf_hex(u); end
  def format_abnf(expr, sep: nil, embedded: nil, sensitive: nil); end
  def format_abnf_char(c); end
  def format_abnf_range(string); end
  def format_ebnf(expr, sep: nil, embedded: nil); end
  def format_ebnf_char(c); end
  def format_ebnf_range(string); end
  def format_ebnf_string(string, quote = nil); end
  def format_isoebnf(expr, sep: nil, embedded: nil); end
  def format_isoebnf_range(string); end
  def initialize(rules, out: nil, html: nil, format: nil, **options); end
  def self.html(*rules, format: nil); end
  def self.print(*rules, format: nil); end
  def self.string(*rules, format: nil); end
  def self.write(out, *rules, format: nil); end
end
module EBNF::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
