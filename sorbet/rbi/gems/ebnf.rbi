# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ebnf/all/ebnf.rbi
#
# ebnf-1.2.0

module EBNF
  def self.parse(input, **options); end
end
module EBNF::BNF
  def make_bnf; end
end
module EBNF::LL1
  def branch; end
  def build_tables; end
  def cleanup; end
  def do_production(lhs); end
  def first; end
  def first_follow(*starts); end
  def follow; end
  def outputTable(io, name, table, indent = nil); end
  def pass; end
  def start; end
  def terminals; end
end
module EBNF::Parser
  def alt(s); end
  def diff(s); end
  def eachRule(scanner); end
  def expression(s); end
  def postfix(s); end
  def primary(s); end
  def ruleParts(rule); end
  def seq(s); end
  def terminal(s); end
end
class EBNF::Base
  def ast; end
  def debug(*args, **options); end
  def depth; end
  def dup; end
  def each(kind, &block); end
  def error(*args, **options); end
  def errors; end
  def errors=(arg0); end
  def find_rule(sym); end
  def initialize(input, format: nil, **options); end
  def progress(*args, **options); end
  def to_html; end
  def to_ruby(output = nil, grammarFile: nil, mod_name: nil); end
  def to_s; end
  def to_sxp; end
  def to_ttl(prefix = nil, ns = nil); end
  include EBNF::BNF
  include EBNF::LL1
  include EBNF::Parser
end
class EBNF::LL1::Lexer
  def each(&block); end
  def each_token(&block); end
  def first(*types); end
  def initialize(input = nil, terminals = nil, **options); end
  def input; end
  def input=(arg0); end
  def lineno; end
  def match_token(*types); end
  def options; end
  def recover(*types); end
  def scanner; end
  def self.tokenize(input, terminals, **options, &block); end
  def self.unescape_codepoints(string); end
  def self.unescape_string(input); end
  def shift; end
  def skip_whitespace; end
  def token(type, value, **options); end
  def valid?; end
  def whitespace; end
  include Enumerable
end
class EBNF::LL1::Lexer::Terminal
  def ==(other); end
  def canonicalize(value); end
  def initialize(type, regexp, **options); end
  def partial_regexp; end
  def regexp; end
  def type; end
  def unescape(string); end
end
class EBNF::LL1::Lexer::Token
  def ===(value); end
  def [](key); end
  def initialize(type, value, **options); end
  def inspect; end
  def lineno; end
  def options; end
  def representation; end
  def to_a; end
  def to_hash; end
  def to_s; end
  def type; end
  def value; end
end
class EBNF::LL1::Lexer::Error < StandardError
  def initialize(message, **options); end
  def input; end
  def lineno; end
  def token; end
end
module EBNF::LL1::Parser
  def accept(type_or_value); end
  def add_prod_data(sym, *values); end
  def add_prod_datum(sym, values); end
  def debug(*args); end
  def depth; end
  def error(node, message, **options); end
  def first_include?(production, token); end
  def follow_include?(production, token); end
  def get_token(recover = nil); end
  def lineno; end
  def onFinish; end
  def onStart(prod); end
  def onTerminal(prod, token); end
  def parse(input = nil, start = nil, **options, &block); end
  def prod_data; end
  def progress(node, *args, &block); end
  def self.included(base); end
  def warn(node, message, **options); end
end
module EBNF::LL1::Parser::ClassMethods
  def eval_with_binding(object); end
  def method_missing(method, *args, &block); end
  def patterns; end
  def production(term, &block); end
  def production_handlers; end
  def start_handlers; end
  def start_production(term, &block); end
  def terminal(term, regexp, **options, &block); end
  def terminal_handlers; end
end
class EBNF::LL1::Parser::Error < StandardError
  def initialize(message, **options); end
  def lineno; end
  def production; end
  def token; end
end
class EBNF::LL1::Scanner < StringScanner
  def encode_utf8(string); end
  def ensure_buffer_full; end
  def eos?; end
  def feed_me; end
  def initialize(input, **options); end
  def input; end
  def rest; end
  def scan(pattern); end
  def self.new(input, **options); end
  def skip(pattern); end
  def terminate; end
end
class EBNF::Rule
  def <=>(other); end
  def ==(other); end
  def add_first(terminals); end
  def add_follow(terminals); end
  def alt?; end
  def build(expr, kind: nil, cleanup: nil, **options); end
  def cclass(txt); end
  def cleanup; end
  def cleanup=(arg0); end
  def comp; end
  def comp=(arg0); end
  def equivalent?(other); end
  def expr; end
  def expr=(arg0); end
  def first; end
  def first_includes_eps?; end
  def follow; end
  def for_sxp; end
  def id; end
  def id=(arg0); end
  def initialize(sym, id, expr, kind: nil, ebnf: nil, first: nil, follow: nil, start: nil, top_rule: nil, cleanup: nil); end
  def inspect; end
  def kind; end
  def kind=(arg0); end
  def make_sym_id(variation = nil); end
  def non_terminals(ast); end
  def orig; end
  def orig=(arg0); end
  def pass?; end
  def rewrite(src_rule, dst_rule); end
  def rule?; end
  def self.from_sxp(sxp); end
  def seq?; end
  def start; end
  def start=(arg0); end
  def starts_with?(sym); end
  def sym; end
  def sym=(arg0); end
  def terminal?; end
  def terminals(ast); end
  def to_bnf; end
  def to_s; end
  def to_sxp; end
  def to_ttl; end
  def ttl_expr(expr, pfx, depth, is_obj = nil); end
end
class EBNF::Writer
  def escape(string, quote = nil); end
  def escape_hex(u); end
  def format(expr, sep = nil); end
  def format_char(c); end
  def format_range(string); end
  def initialize(rules, out: nil, html: nil, **options); end
  def self.html(*rules); end
  def self.print(*rules); end
  def self.string(*rules); end
  def self.write(out, *rules); end
end
module EBNF::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
