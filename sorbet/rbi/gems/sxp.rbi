# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sxp/all/sxp.rbi
#
# sxp-1.1.0

module SXP
  def self.parse(input, **options); end
  def self.parse_all(input, **options); end
  def self.parse_file(filename, **options); end
  def self.parse_files(*filenames); end
  def self.parse_uri(url, **options); end
  def self.parse_url(url, **options); end
  def self.read(input, **options); end
  def self.read_all(input, **options); end
  def self.read_file(filename, **options); end
  def self.read_files(*filenames); end
  def self.read_uri(url, **options); end
  def self.read_url(url, **options); end
  def self.write(sxp, output = nil); end
end
module SXP::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
class Symbol
  def keyword?; end
  def to_sxp; end
end
class RDF::URI
  def lexical; end
  def lexical=(value); end
  def to_sxp; end
end
class Object < BasicObject
  def to_sxp; end
end
class NilClass
  def to_sxp; end
end
class FalseClass
  def to_sxp; end
end
class TrueClass
  def to_sxp; end
end
class String
  def to_sxp; end
end
class Integer < Numeric
  def to_sxp; end
end
class BigDecimal < Numeric
  def to_sxp; end
end
class Float < Numeric
  def to_sxp; end
end
class Array
  def to_sxp; end
end
class Time
  def to_sxp; end
end
class Regexp
  def to_sxp; end
end
class RDF::Node
  def to_sxp; end
end
class RDF::Literal
  def to_sxp; end
end
class RDF::Query
  def to_sxp; end
end
class RDF::Query::Pattern < RDF::Statement
  def to_sxp; end
end
class RDF::Query::Variable
  def to_sxp; end
end
class SXP::Pair
  def dotted?; end
  def empty?; end
  def head; end
  def head=(arg0); end
  def initialize(head = nil, tail = nil); end
  def inspect; end
  def proper?; end
  def tail; end
  def tail=(arg0); end
  def to_a; end
end
class SXP::List < SXP::Pair
  def &(other); end
  def *(times); end
  def +(other); end
  def -(other); end
  def <<(object); end
  def <=>(other); end
  def ==(other); end
  def [](*args); end
  def []=(*args); end
  def assoc(object); end
  def at(index); end
  def clear; end
  def collect!(&block); end
  def compact!; end
  def compact; end
  def concat(other); end
  def delete(object, &block); end
  def delete_at(index); end
  def delete_if(&block); end
  def each(&block); end
  def each_index(&block); end
  def empty?; end
  def eql?(other); end
  def fetch(*args, &block); end
  def fill(*args, &block); end
  def first(count = nil); end
  def flatten!; end
  def flatten; end
  def head; end
  def include?(object); end
  def index(object); end
  def initialize(elements = nil, &block); end
  def insert(index, *objects); end
  def inspect; end
  def join(separator = nil); end
  def last(count = nil); end
  def length; end
  def map!(&block); end
  def nitems; end
  def pack(template); end
  def pop; end
  def push(*objects); end
  def rassoc(key); end
  def reject!(&block); end
  def replace(other_list); end
  def rest; end
  def reverse!; end
  def reverse; end
  def reverse_each(&block); end
  def rindex(object); end
  def self.[](*elements); end
  def shift; end
  def size; end
  def slice!(*args); end
  def slice(*args); end
  def sort!; end
  def sort(&block); end
  def tail; end
  def to_list; end
  def to_pair; end
  def to_s; end
  def transpose; end
  def uniq!; end
  def uniq; end
  def unshift(*objects); end
  def values_at(*selector); end
  def |(other); end
  include Enumerable
end
class SXP::Generator
  def initialize(buffer); end
  def render(sexp); end
  def self.print(*sxps); end
  def self.string(*sxps); end
  def self.write(out, *sxps); end
end
class SXP::Generator::Block
  def do_indent(offset = nil); end
  def formatted; end
  def indent; end
  def initialize(obj, indent); end
  def length; end
  def sxp?; end
  def to_sxp; end
end
class SXP::Reader
  def each(&block); end
  def eof?; end
  def initialize(input, **options, &block); end
  def input; end
  def options; end
  def peek_char; end
  def read(eof: nil, eol: nil, list_term: nil, **options); end
  def read_all(**options); end
  def read_atom; end
  def read_char; end
  def read_character; end
  def read_chars(count = nil); end
  def read_files(*filenames); end
  def read_integer(base = nil); end
  def read_list(list_term = nil); end
  def read_literal; end
  def read_sharp; end
  def read_string; end
  def read_token; end
  def self.read(input, **options); end
  def self.read_all(input, **options); end
  def self.read_file(filename, **options); end
  def self.read_url(url, **options); end
  def skip(eof: nil, eol: nil, list_term: nil, **options); end
  def skip_char; end
  def skip_comments; end
  def skip_line; end
  def unread(string); end
  include Enumerable
end
class SXP::Reader::Error < StandardError
end
class SXP::Reader::EOF < SXP::Reader::Error
end
class SXP::Reader::Basic < SXP::Reader
  def read_atom; end
  def read_character; end
  def read_literal; end
  def read_string; end
  def read_token; end
end
class SXP::Reader::Extended < SXP::Reader::Basic
  def read_token; end
  def skip_comments; end
end
class SXP::Reader::Scheme < SXP::Reader::Extended
  def initialize(input, version: nil, **options, &block); end
  def read_atom; end
  def read_character; end
  def read_sharp; end
  def read_token; end
end
class SXP::Reader::CommonLisp < SXP::Reader::Basic
  def initialize(input, **options, &block); end
  def read_character; end
  def read_function; end
  def read_quote; end
  def read_sharp; end
  def read_symbol(delimiter = nil); end
  def read_token; end
  def read_vector; end
  def skip_comments; end
end
class SXP::Reader::SPARQL < SXP::Reader::Extended
  def base_uri; end
  def base_uri=(arg0); end
  def initialize(input, **options, &block); end
  def prefix(name, uri = nil); end
  def prefixes; end
  def prefixes=(arg0); end
  def read_atom; end
  def read_rdf_literal; end
  def read_rdf_uri; end
  def read_token; end
  def skip_comments; end
  def variable(id, distinguished: nil, existential: nil); end
end
