# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shoulda-matchers` gem.
# Please instead update this file by running `bin/tapioca gem shoulda-matchers`.

# typed: true

module Shoulda; end

module Shoulda::Matchers
  extend ::Shoulda::Matchers::WordWrap

  class << self
    def assertion_exception_class; end
    def assertion_exception_class=(_arg0); end
    def configuration; end
    def configure; end
    def integrations; end
    def warn(message); end
    def warn_about_deprecated_method(old_method, new_method); end
  end
end

module Shoulda::Matchers::ActionController
  def filter_param(key); end
  def permit(*params); end
  def redirect_to(url_or_description, &block); end
  def render_template(options = T.unsafe(nil), message = T.unsafe(nil)); end
  def render_with_layout(expected_layout = T.unsafe(nil)); end
  def rescue_from(exception); end
  def respond_with(status); end
  def route(method, path, port: T.unsafe(nil)); end
  def set_flash; end
  def set_session; end
  def use_after_action(callback); end
  def use_around_action(callback); end
  def use_before_action(callback); end
end

class Shoulda::Matchers::ActionController::CallbackMatcher
  def initialize(method_name, kind, callback_type); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(controller); end

  protected

  def callback_type; end
  def callbacks; end
  def controller; end
  def controller_class; end
  def kind; end
  def method_name; end
end

class Shoulda::Matchers::ActionController::FilterParamMatcher
  def initialize(key); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(_controller); end

  private

  def filtered_keys; end
  def filters_key?; end
end

class Shoulda::Matchers::ActionController::FlashStore
  def initialize; end

  def controller; end
  def controller=(_arg0); end
  def empty?(*_arg0, &_arg1); end
  def has_key?(key); end
  def has_value?(expected_value); end
  def name; end
  def use_now!; end

  private

  def copy_discard_if_necessary(original_flash, new_flash); end
  def copy_flashes(original_flash, new_flash); end
  def copy_of_flash_from_controller; end
  def flash; end
  def keys_to_discard; end
  def set_values; end
  def values_to_check; end

  class << self
    def future; end
    def now; end
  end
end

class Shoulda::Matchers::ActionController::PermitMatcher
  def initialize(expected_permitted_parameter_names); end

  def add_params(params); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def for(action, options = T.unsafe(nil)); end
  def in_context(context); end
  def matches?(controller); end
  def on(subparameter_name); end
  def stubbed_params=(_arg0); end

  protected

  def action; end
  def actual_permitted_parameter_names; end
  def context; end
  def controller; end
  def default_verb; end
  def double_collections_by_parameter_name; end
  def ensure_action_and_verb_present!; end
  def expectation; end
  def expected_permitted_parameter_names; end
  def format_parameter_names(parameter_names); end
  def parameter_names_as_sentence; end
  def parameters_double_registry; end
  def reality; end
  def request_params; end
  def subparameter_name; end
  def unpermitted_parameter_names; end
  def verb; end
end

class Shoulda::Matchers::ActionController::PermitMatcher::ActionNotDefinedError < ::StandardError
  def message; end
end

class Shoulda::Matchers::ActionController::PermitMatcher::CompositeParametersDoubleRegistry
  def initialize; end

  def permitted_parameter_names(options = T.unsafe(nil)); end
  def register; end

  protected

  def parameters_double_registries; end
end

class Shoulda::Matchers::ActionController::PermitMatcher::ParametersDoubleRegistry
  def initialize(params); end

  def permitted_parameter_names(args = T.unsafe(nil)); end
  def register; end

  protected

  def double_collections_by_parameter_name; end
  def params; end

  private

  def register_double_for_permit_against(params, subparameter_name); end
  def register_double_for_permit_on(double_collection); end
  def register_double_for_require_on(double_collection); end

  class << self
    def permitted_parameter_names_within(double_collection); end
  end
end

Shoulda::Matchers::ActionController::PermitMatcher::ParametersDoubleRegistry::TOP_LEVEL = T.let(T.unsafe(nil), Object)

class Shoulda::Matchers::ActionController::PermitMatcher::VerbNotDefinedError < ::StandardError
  def message; end
end

class Shoulda::Matchers::ActionController::RedirectToMatcher
  def initialize(url_or_description, context, &block); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(controller); end

  private

  def redirects_to_url?; end
  def url; end
end

class Shoulda::Matchers::ActionController::RenderTemplateMatcher
  def initialize(options, message, context); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(controller); end

  private

  def renders_template?; end
end

class Shoulda::Matchers::ActionController::RenderWithLayoutMatcher
  def initialize(expected_layout); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(controller); end

  private

  def expectation; end
  def recorded_layouts; end
  def rendered_layouts; end
  def rendered_with_expected_layout?; end
  def rendered_with_layout?; end
  def result; end
end

class Shoulda::Matchers::ActionController::RescueFromMatcher
  def initialize(exception); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(controller); end
  def with(method); end

  protected

  def controller; end
  def exception; end
  def expectation; end
  def expected_method; end
  def handler_exists?; end
  def handlers; end
  def method_name_matches?; end
  def rescues_from_exception?; end
end

class Shoulda::Matchers::ActionController::RespondWithMatcher
  def initialize(status); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(controller); end

  protected

  def correct_status_code?; end
  def correct_status_code_range?; end
  def expectation; end
  def response_code; end
  def symbol_to_status_code(potential_symbol); end
end

class Shoulda::Matchers::ActionController::RouteMatcher
  def initialize(context, method, path, port: T.unsafe(nil)); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(controller); end
  def to(*args); end

  private

  def add_port_to_path(path, port); end
  def context; end
  def guess_controller_if_necessary(controller); end
  def method; end
  def normalize_path(path); end
  def params; end
  def path; end
  def route_recognized?; end
end

class Shoulda::Matchers::ActionController::RouteParams
  def initialize(args); end

  def normalize; end

  protected

  def args; end
  def controller_and_action_given_as_string?; end
  def extract_params_from_string; end
  def normalize_values(hash); end
  def stringify(value); end
  def stringify_params; end
  def symbolize_or_stringify(key, value); end
end

Shoulda::Matchers::ActionController::RouteParams::PARAMS_TO_SYMBOLIZE = T.let(T.unsafe(nil), Array)

class Shoulda::Matchers::ActionController::SessionStore
  def controller; end
  def controller=(_arg0); end
  def empty?; end
  def has_key?(key); end
  def has_value?(expected_value); end
  def name; end

  private

  def session; end
end

class Shoulda::Matchers::ActionController::SetFlashMatcher
  extend ::Forwardable

  def initialize; end

  def [](key); end
  def description(*args, &block); end
  def failure_message(*args, &block); end
  def failure_message_for_should(*args, &block); end
  def failure_message_for_should_not(*args, &block); end
  def failure_message_when_negated(*args, &block); end
  def in_context(context); end
  def matches?(*args, &block); end
  def now; end
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  def expected_value; end
  def key; end
  def underlying_matcher; end
end

class Shoulda::Matchers::ActionController::SetFlashMatcher::QualifierOrderError < ::StandardError
  def message; end
end

class Shoulda::Matchers::ActionController::SetSessionMatcher
  extend ::Forwardable

  def initialize; end

  def [](key); end
  def description(*args, &block); end
  def failure_message(*args, &block); end
  def failure_message_for_should(*args, &block); end
  def failure_message_for_should_not(*args, &block); end
  def failure_message_when_negated(*args, &block); end
  def in_context(context); end
  def matches?(*args, &block); end
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  def underlying_matcher; end
end

class Shoulda::Matchers::ActionController::SetSessionOrFlashMatcher
  def initialize(store); end

  def [](key); end
  def description; end
  def failure_message; end
  def failure_message_for_should; end
  def failure_message_for_should_not; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(controller); end
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  def context; end
  def controller; end
  def expected_value; end
  def key; end
  def store; end

  private

  def context_set?; end
  def expectation_description; end
  def expected_value_matches?; end
  def expected_value_set?; end
  def key_matches?; end
  def key_set?; end
end

module Shoulda::Matchers::ActiveModel
  def allow_value(*values); end
  def allow_values(*values); end
  def have_secure_password(attr = T.unsafe(nil)); end
  def validate_absence_of(attr); end
  def validate_acceptance_of(attr); end
  def validate_confirmation_of(attr); end
  def validate_exclusion_of(attr); end
  def validate_inclusion_of(attr); end
  def validate_length_of(attr); end
  def validate_numericality_of(attr); end
  def validate_presence_of(attr); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  def initialize(*values); end

  def _after_setting_value(&callback); end
  def after_setting_value_callback; end
  def attribute_changed_value_message=(_arg0); end
  def attribute_to_check_message_against; end
  def attribute_to_set; end
  def context; end
  def description; end
  def does_not_match?(instance); end
  def expected_message; end
  def expects_custom_validation_message?; end
  def expects_strict?; end
  def failure_message; end
  def failure_message_preface=(_arg0); end
  def failure_message_when_negated; end
  def for(attribute_name); end
  def instance; end
  def last_attribute_setter_used; end
  def last_value_set; end
  def matches?(instance); end
  def model; end
  def on(context); end
  def simple_description; end
  def strict(expects_strict = T.unsafe(nil)); end
  def values_to_preset=(_arg0); end
  def with_message(message, given_options = T.unsafe(nil)); end

  protected

  def options; end
  def result; end
  def values_to_preset; end
  def values_to_set; end

  private

  def attribute_changed_value_message; end
  def attribute_setters_and_validators_for_values_to_set; end
  def attribute_setters_for_values_to_preset; end
  def default_attribute_changed_value_message; end
  def default_attribute_message; end
  def default_attribute_message_values; end
  def default_expected_message; end
  def default_failure_message_preface; end
  def description_for_resulting_attribute_setter; end
  def descriptions_for_preset_values; end
  def failure_message_preface; end
  def human_attribute_name; end
  def include_attribute_changed_value_message?; end
  def inspected_values_to_set; end
  def model_name; end
  def run(strategy); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeChangedValueError < ::Shoulda::Matchers::Error
  def attribute_name; end
  def attribute_name=(_arg0); end
  def matcher_name; end
  def matcher_name=(_arg0); end
  def message; end
  def model; end
  def model=(_arg0); end
  def successful?; end
  def value_read; end
  def value_read=(_arg0); end
  def value_written; end
  def value_written=(_arg0); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeDoesNotExistError < ::Shoulda::Matchers::Error
  def attribute_name; end
  def attribute_name=(_arg0); end
  def message; end
  def model; end
  def model=(_arg0); end
  def successful?; end
  def value; end
  def value=(_arg0); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetter
  def initialize(args); end

  def attribute_changed_value?; end
  def attribute_name; end
  def check; end
  def checked?; end
  def description; end
  def failure_message; end
  def result_of_checking; end
  def result_of_setting; end
  def run; end
  def run!; end
  def set; end
  def set!; end
  def set?; end
  def successful?; end
  def successfully_checked?; end
  def successfully_set?; end
  def unsuccessful?; end
  def unsuccessfully_checked?; end
  def value_read; end
  def value_written; end

  protected

  def after_set_callback; end
  def args; end
  def matcher_name; end
  def object; end

  private

  def active_resource_object?; end
  def attribute_changed_value!; end
  def attribute_changed_value_error; end
  def attribute_does_not_exist!; end
  def attribute_does_not_exist_error; end
  def attribute_exists?; end
  def attribute_is_an_enum?; end
  def defined_enums; end
  def enum_values; end
  def ignore_interference_by_writer; end
  def model; end
  def raise_attribute_changed_value_error?; end
  def successful_check; end
  def successful_setting; end
  def value_read_is_expected_for_an_enum?; end

  class << self
    def set(args); end
  end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetterAndValidator
  extend ::Forwardable

  def initialize(allow_value_matcher, attribute_name, value); end

  def after_setting_value_callback(*args, &block); end
  def attribute_setter; end
  def attribute_setter_description; end
  def attribute_to_check_message_against(*args, &block); end
  def context(*args, &block); end
  def expected_message(*args, &block); end
  def expects_strict?(*args, &block); end
  def ignore_interference_by_writer(*args, &block); end
  def instance(*args, &block); end
  def validator; end

  protected

  def allow_value_matcher; end
  def attribute_name; end
  def value; end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetters
  include ::Enumerable

  def initialize(allow_value_matcher, values); end

  def each(&block); end
  def first_failing; end

  protected

  def tuples; end

  private

  def does_not_match?(tuple); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSettersAndValidators
  include ::Enumerable

  def initialize(allow_value_matcher, values); end

  def each(&block); end
  def first_failing; end
  def first_passing; end

  protected

  def tuples; end

  private

  def does_not_match?(tuple); end
  def matches?(tuple); end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulCheck
  def successful?; end
end

class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulSetting
  def successful?; end
end

class Shoulda::Matchers::ActiveModel::CouldNotDetermineValueOutsideOfArray < ::RuntimeError; end

class Shoulda::Matchers::ActiveModel::CouldNotSetPasswordError < ::Shoulda::Matchers::Error
  def message; end
  def model; end
  def model=(_arg0); end

  private

  def model_name; end
  def record_name; end

  class << self
    def create(model); end
  end
end

class Shoulda::Matchers::ActiveModel::DisallowValueMatcher
  extend ::Forwardable

  def initialize(value); end

  def _after_setting_value(*args, &block); end
  def attribute_changed_value_message=(*args, &block); end
  def attribute_to_set(*args, &block); end
  def description(*args, &block); end
  def does_not_match?(subject); end
  def expects_strict?(*args, &block); end
  def failure_message; end
  def failure_message_preface(*args, &block); end
  def failure_message_preface=(*args, &block); end
  def failure_message_when_negated; end
  def for(attribute); end
  def ignore_interference_by_writer(*args, &block); end
  def ignoring_interference_by_writer(value = T.unsafe(nil)); end
  def last_attribute_setter_used(*args, &block); end
  def last_value_set(*args, &block); end
  def matches?(subject); end
  def model(*args, &block); end
  def on(context); end
  def simple_description(*args, &block); end
  def strict(strict = T.unsafe(nil)); end
  def values_to_preset=(*args, &block); end
  def with_message(message, options = T.unsafe(nil)); end

  protected

  def allow_matcher; end
end

class Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher
  def initialize(attribute); end

  def description; end
  def failure_message; end
  def matches?(subject); end

  protected

  def subject; end
  def validate; end

  private

  def authenticate_method; end
  def expected_methods; end
end

Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::CORRECT_PASSWORD = T.let(T.unsafe(nil), String)
Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::INCORRECT_PASSWORD = T.let(T.unsafe(nil), String)
Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::MESSAGES = T.let(T.unsafe(nil), Hash)

module Shoulda::Matchers::ActiveModel::Helpers
  def default_error_message(type, options = T.unsafe(nil)); end
  def format_validation_errors(errors); end
  def pretty_error_messages(object); end
end

class Shoulda::Matchers::ActiveModel::NonNullableBooleanError < ::Shoulda::Matchers::Error
  def attribute; end
  def attribute=(_arg0); end
  def message; end

  class << self
    def create(attribute); end
  end
end

module Shoulda::Matchers::ActiveModel::NumericalityMatchers; end

class Shoulda::Matchers::ActiveModel::NumericalityMatchers::ComparisonMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  def initialize(numericality_matcher, value, operator); end

  def comparison_description; end
  def expects_custom_validation_message?; end
  def failure_message; end
  def failure_message_when_negated; end
  def for(attribute); end
  def matches?(subject); end
  def simple_description; end
  def with_message(message); end

  private

  def all_bounds_correct?; end
  def assertions; end
  def comparison_combos; end
  def comparison_expectation; end
  def diffs_to_compare; end
  def failing_submatchers; end
  def last_failing_submatcher; end
  def submatcher_method_names; end
  def submatchers; end
  def submatchers_and_results; end
end

Shoulda::Matchers::ActiveModel::NumericalityMatchers::ComparisonMatcher::ERROR_MESSAGES = T.let(T.unsafe(nil), Hash)

class Shoulda::Matchers::ActiveModel::NumericalityMatchers::EvenNumberMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_adjective; end
  def diff_to_compare; end
  def simple_description; end

  protected

  def disallowed_value; end
  def wrap_disallow_value_matcher(matcher); end
end

Shoulda::Matchers::ActiveModel::NumericalityMatchers::EvenNumberMatcher::NON_EVEN_NUMBER_VALUE = T.let(T.unsafe(nil), Integer)

class Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  extend ::Forwardable

  def initialize(numeric_type_matcher, attribute); end

  def allowed_type_adjective; end
  def allowed_type_name; end
  def diff_to_compare; end
  def does_not_match?(*args, &block); end
  def expects_custom_validation_message?(*args, &block); end
  def expects_strict?(*args, &block); end
  def failure_message(*args, &block); end
  def failure_message_when_negated(*args, &block); end
  def ignore_interference_by_writer(*args, &block); end
  def ignoring_interference_by_writer(*args, &block); end
  def matches?(*args, &block); end
  def on(*args, &block); end
  def strict(*args, &block); end
  def with_message(*args, &block); end

  protected

  def attribute; end
  def disallowed_value; end
  def wrap_disallow_value_matcher(_matcher); end

  private

  def disallow_value_matcher; end
end

class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OddNumberMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_adjective; end
  def diff_to_compare; end
  def simple_description; end

  protected

  def disallowed_value; end
  def wrap_disallow_value_matcher(matcher); end
end

Shoulda::Matchers::ActiveModel::NumericalityMatchers::OddNumberMatcher::NON_ODD_NUMBER_VALUE = T.let(T.unsafe(nil), Integer)

class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OnlyIntegerMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_name; end
  def diff_to_compare; end
  def simple_description; end

  protected

  def disallowed_value; end
  def wrap_disallow_value_matcher(matcher); end
end

Shoulda::Matchers::ActiveModel::NumericalityMatchers::OnlyIntegerMatcher::NON_INTEGER_VALUE = T.let(T.unsafe(nil), Float)
module Shoulda::Matchers::ActiveModel::Qualifiers; end

module Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil
  def initialize(*args); end

  def allow_nil; end

  protected

  def expects_to_allow_nil?; end
end

class Shoulda::Matchers::ActiveModel::Qualifiers::IgnoreInterferenceByWriter
  def initialize(argument = T.unsafe(nil)); end

  def always?; end
  def changed?; end
  def condition; end
  def considering?(value); end
  def default_to(argument); end
  def never?; end
  def set(argument); end
  def setting; end

  private

  def condition_matches?(value); end
  def invalid_argument_error(invalid_argument); end
end

module Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter
  def initialize(*_arg0); end

  def ignore_interference_by_writer; end
  def ignoring_interference_by_writer(value = T.unsafe(nil)); end
end

class Shoulda::Matchers::ActiveModel::ValidateAbsenceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  def initialize(attribute); end

  def does_not_match?(subject); end
  def matches?(subject); end
  def simple_description; end

  private

  def array_column?; end
  def collection?; end
  def column_type; end
  def reflection; end
  def value; end
end

class Shoulda::Matchers::ActiveModel::ValidateAcceptanceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  def initialize(attribute); end

  def does_not_match?(subject); end
  def matches?(subject); end
  def simple_description; end
end

class Shoulda::Matchers::ActiveModel::ValidateConfirmationOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  def initialize(attribute); end

  def attribute; end
  def confirmation_attribute; end
  def does_not_match?(subject); end
  def matches?(subject); end
  def simple_description; end

  private

  def allows_different_value; end
  def allows_missing_confirmation; end
  def allows_same_value; end
  def disallows_different_value; end
  def disallows_missing_confirmation; end
  def disallows_same_value; end
  def qualify_matcher(matcher, confirmation_attribute_value); end
end

class Shoulda::Matchers::ActiveModel::ValidateExclusionOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  def initialize(attribute); end

  def does_not_match?(subject); end
  def in_array(array); end
  def in_range(range); end
  def matches?(subject); end
  def simple_description; end

  private

  def allows_any_values_in_array?; end
  def allows_higher_value; end
  def allows_lower_value; end
  def allows_maximum_value; end
  def allows_minimum_value; end
  def disallows_all_values_in_array?; end
  def disallows_higher_value; end
  def disallows_lower_value; end
  def disallows_maximum_value; end
  def disallows_minimum_value; end
  def inspect_message; end
  def inspected_array; end
end

class Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  def initialize(attribute); end

  def allow_nil; end
  def does_not_match?(subject); end
  def expects_to_allow_nil?; end
  def in_array(array); end
  def in_range(range); end
  def matches?(subject); end
  def simple_description; end
  def with_high_message(message); end
  def with_low_message(message); end
  def with_message(message); end

  private

  def allows_all_values_in_array?; end
  def allows_any_value_outside_of_array?; end
  def allows_higher_value; end
  def allows_lower_value; end
  def allows_maximum_value; end
  def allows_minimum_value; end
  def allows_nil_value?; end
  def attribute_allows_nil?; end
  def attribute_column; end
  def attribute_type; end
  def boolean_outside_values; end
  def column_type_to_attribute_type(type); end
  def disallows_all_values_outside_of_array?; end
  def disallows_any_values_in_array?; end
  def disallows_higher_value; end
  def disallows_lower_value; end
  def disallows_maximum_value; end
  def disallows_minimum_value; end
  def disallows_nil_value?; end
  def does_not_match_for_array?; end
  def does_not_match_for_range?; end
  def inspected_array; end
  def matches_for_array?; end
  def matches_for_range?; end
  def outside_values; end
  def value_to_attribute_type(value); end
  def values_outside_of_array; end
end

Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DATE = T.let(T.unsafe(nil), Date)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DATETIME = T.let(T.unsafe(nil), DateTime)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DECIMAL = T.let(T.unsafe(nil), BigDecimal)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_INTEGER = T.let(T.unsafe(nil), Integer)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_STRING = T.let(T.unsafe(nil), String)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_TIME = T.let(T.unsafe(nil), Time)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BLANK_VALUES = T.let(T.unsafe(nil), Array)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BOOLEAN_ALLOWS_BOOLEAN_MESSAGE = T.let(T.unsafe(nil), String)
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BOOLEAN_ALLOWS_NIL_MESSAGE = T.let(T.unsafe(nil), String)

class Shoulda::Matchers::ActiveModel::ValidateLengthOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  def initialize(attribute); end

  def allow_nil; end
  def does_not_match?(subject); end
  def is_at_least(length); end
  def is_at_most(length); end
  def is_equal_to(length); end
  def matches?(subject); end
  def simple_description; end
  def with_long_message(message); end
  def with_message(message); end
  def with_short_message(message); end

  private

  def allow_nil_does_not_match?; end
  def allow_nil_matches?; end
  def allows_higher_length?; end
  def allows_length_of?(length, message); end
  def allows_lower_length?; end
  def allows_maximum_length?; end
  def allows_minimum_length?; end
  def disallows_higher_length?; end
  def disallows_length_of?(length, message); end
  def disallows_lower_length?; end
  def disallows_maximum_length?; end
  def disallows_minimum_length?; end
  def expects_to_allow_nil?; end
  def lower_bound_does_not_match?; end
  def lower_bound_matches?; end
  def string_of_length(length); end
  def translated_long_message; end
  def translated_short_message; end
  def upper_bound_does_not_match?; end
  def upper_bound_matches?; end
end

class Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  def initialize(attribute); end

  def allow_nil; end
  def description; end
  def diff_to_compare; end
  def does_not_match?(subject); end
  def even; end
  def expects_custom_validation_message?; end
  def expects_strict?; end
  def expects_to_allow_nil?; end
  def failure_message; end
  def failure_message_when_negated; end
  def given_numeric_column?; end
  def is_equal_to(value); end
  def is_greater_than(value); end
  def is_greater_than_or_equal_to(value); end
  def is_less_than(value); end
  def is_less_than_or_equal_to(value); end
  def is_other_than(value); end
  def matches?(subject); end
  def odd; end
  def on(context); end
  def only_integer; end
  def simple_description; end
  def strict; end
  def with_message(message); end

  private

  def add_disallow_value_matcher; end
  def add_submatcher(submatcher); end
  def attribute_is_active_record_column?; end
  def build_submatcher_failure_message_for(submatcher, failure_message_method); end
  def column_type; end
  def columns_hash; end
  def comparison_descriptions; end
  def comparison_matcher_for(value, operator); end
  def failure_message_for_first_submatcher_that_fails_to_match; end
  def failure_message_for_first_submatcher_that_fails_to_not_match; end
  def first_submatcher_that_fails_to_match; end
  def first_submatcher_that_fails_to_not_match; end
  def full_allowed_type; end
  def has_been_qualified?; end
  def matches_or_does_not_match?(subject); end
  def model; end
  def non_numeric_value; end
  def number_of_submatchers_for_failure_message; end
  def overall_failure_message; end
  def overall_failure_message_when_negated; end
  def prepare_submatcher(submatcher); end
  def qualify_submatchers; end
  def submatcher_comparison_descriptions; end
end

Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher::DEFAULT_DIFF_TO_COMPARE = T.let(T.unsafe(nil), Integer)
Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher::NUMERIC_NAME = T.let(T.unsafe(nil), String)

class Shoulda::Matchers::ActiveModel::ValidatePresenceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil

  def initialize(attribute); end

  def does_not_match?(subject); end
  def failure_message; end
  def matches?(subject); end
  def simple_description; end

  private

  def allows_and_double_checks_value_of!(value); end
  def allows_original_or_typecast_value?(value); end
  def association?; end
  def association_name; end
  def association_options; end
  def association_reflection; end
  def attachment?; end
  def attribute_accepts_string_values?; end
  def attribute_serialization_coder; end
  def attribute_type; end
  def belongs_to_association_being_validated?; end
  def belongs_to_association_configured_to_be_required?; end
  def collection_association?; end
  def disallowed_values; end
  def disallows_and_double_checks_value_of!(value); end
  def disallows_original_or_typecast_value?(value); end
  def example_of_belongs_to(with: T.unsafe(nil)); end
  def model; end
  def model_has_associations?(associations); end
  def possibly_ignore_interference_by_writer; end
  def presence_validation_exists_on_attribute?; end
  def reason_for_existing_presence_validation; end
  def secure_password_being_validated?; end
  def should_add_footnote_about_belongs_to?; end
  def suggestions_for_belongs_to; end
end

class Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  def initialize(attribute); end

  def allow_blank; end
  def description; end
  def does_not_match?(subject); end
  def expects_custom_validation_message?; end
  def expects_strict?; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end
  def on(context); end
  def strict; end
  def with_message(expected_message); end

  protected

  def allow_blank_does_not_match?; end
  def allow_blank_matches?; end
  def allow_value_matcher(value, message = T.unsafe(nil), &block); end
  def allows_value_of(value, message = T.unsafe(nil), &block); end
  def attribute; end
  def context; end
  def disallow_value_matcher(value, message = T.unsafe(nil), &block); end
  def disallows_value_of(value, message = T.unsafe(nil), &block); end
  def last_submatcher_run; end
  def model; end
  def subject; end

  private

  def blank_values; end
  def build_allow_or_disallow_value_matcher(args); end
  def expects_to_allow_blank?; end
  def failure_reason; end
  def failure_reason_when_negated; end
  def options; end
  def overall_failure_message; end
  def overall_failure_message_when_negated; end
  def run_allow_or_disallow_matcher(matcher); end
end

class Shoulda::Matchers::ActiveModel::ValidationMatcher::BuildDescription
  def initialize(matcher, main_description); end

  def call; end

  protected

  def main_description; end
  def matcher; end

  private

  def clause_for_allow_blank_or_nil; end
  def description_clauses_for_qualifiers; end

  class << self
    def call(matcher, main_description); end
  end
end

class Shoulda::Matchers::ActiveModel::Validator
  include ::Shoulda::Matchers::ActiveModel::Helpers

  def initialize(record, attribute, options = T.unsafe(nil)); end

  def all_formatted_validation_error_messages; end
  def call; end
  def captured_validation_exception?; end
  def has_messages?; end
  def type_of_message_matched?; end
  def validation_exception_message; end

  protected

  def attribute; end
  def context; end
  def record; end

  private

  def all_validation_errors; end
  def captured_range_error?; end
  def expects_strict?; end
  def matched_messages; end
  def messages; end
  def messages_match?; end
  def perform_validation; end
  def validation_error_messages; end
  def validation_result; end
end

module Shoulda::Matchers::ActiveRecord
  def accept_nested_attributes_for(name); end
  def belong_to(name); end
  def define_enum_for(attribute_name); end
  def have_and_belong_to_many(name); end
  def have_db_column(column); end
  def have_db_index(columns); end
  def have_implicit_order_column(column_name); end
  def have_many(name); end
  def have_many_attached(name); end
  def have_one(name); end
  def have_one_attached(name); end
  def have_readonly_attribute(value); end
  def have_rich_text(rich_text_attribute); end
  def have_secure_token(token_attribute = T.unsafe(nil)); end
  def serialize(name); end
  def validate_uniqueness_of(attr); end
end

class Shoulda::Matchers::ActiveRecord::AcceptNestedAttributesForMatcher
  def initialize(name); end

  def allow_destroy(allow_destroy); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def limit(limit); end
  def matches?(subject); end
  def update_only(update_only); end

  protected

  def allow_destroy_correct?; end
  def config; end
  def exists?; end
  def expectation; end
  def limit_correct?; end
  def model_class; end
  def model_config; end
  def should_or_should_not(value); end
  def update_only_correct?; end
  def verify_option_is_correct(option, failure_message); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatcher
  def initialize(macro, name); end

  def associated_class(*_arg0, &_arg1); end
  def autosave(autosave); end
  def class_name(class_name); end
  def conditions(conditions); end
  def counter_cache(counter_cache = T.unsafe(nil)); end
  def dependent(dependent); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def index_errors(index_errors); end
  def inverse_of(inverse_of); end
  def join_table(join_table_name); end
  def join_table_name; end
  def matches?(subject); end
  def model_class(*_arg0, &_arg1); end
  def name; end
  def option_verifier; end
  def optional(optional = T.unsafe(nil)); end
  def options; end
  def order(order); end
  def polymorphic?(*_arg0, &_arg1); end
  def reflection(*_arg0, &_arg1); end
  def required(required = T.unsafe(nil)); end
  def source(source); end
  def through(through); end
  def through?(*_arg0, &_arg1); end
  def touch(touch = T.unsafe(nil)); end
  def validate(validate = T.unsafe(nil)); end
  def with_foreign_key(foreign_key); end
  def with_primary_key(primary_key); end
  def without_validating_presence; end

  protected

  def actual_foreign_key; end
  def add_submatcher(matcher_class, *args); end
  def association_exists?; end
  def autosave_correct?; end
  def belongs_foreign_key_missing?; end
  def belongs_to_required_by_default?; end
  def class_exists?; end
  def class_has_foreign_key?(klass); end
  def class_name_correct?; end
  def column_names_for(klass); end
  def conditions_correct?; end
  def expectation; end
  def failing_submatchers; end
  def foreign_key_correct?; end
  def foreign_key_exists?; end
  def foreign_key_failure_message(klass, foreign_key); end
  def foreign_key_reflection; end
  def has_column?(klass, column); end
  def has_foreign_key_missing?; end
  def index_errors_correct?; end
  def join_table_correct?; end
  def join_table_matcher; end
  def macro; end
  def macro_correct?; end
  def macro_description; end
  def macro_supports_primary_key?; end
  def missing; end
  def missing_options; end
  def missing_options_for_failing_submatchers; end
  def primary_key_correct?(klass); end
  def primary_key_exists?; end
  def reflector; end
  def remove_submatcher(matcher_class); end
  def subject; end
  def submatchers; end
  def submatchers_match?; end
  def touch_correct?; end
  def validate_correct?; end
  def validate_foreign_key(klass); end
  def validate_inverse_of_through_association; end
end

Shoulda::Matchers::ActiveRecord::AssociationMatcher::MACROS = T.let(T.unsafe(nil), Hash)
module Shoulda::Matchers::ActiveRecord::AssociationMatchers; end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::CounterCacheMatcher
  def initialize(counter_cache, name); end

  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end

  protected

  def counter_cache; end
  def counter_cache=(_arg0); end
  def name; end
  def name=(_arg0); end
  def option_verifier; end
  def subject; end
  def subject=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::DependentMatcher
  def initialize(dependent, name); end

  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end

  protected

  def dependent; end
  def dependent=(_arg0); end
  def name; end
  def name=(_arg0); end
  def subject; end
  def subject=(_arg0); end

  private

  def generate_missing_option; end
  def option_matches?; end
  def option_type; end
  def option_verifier; end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::InverseOfMatcher
  def initialize(inverse_of, name); end

  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end

  protected

  def inverse_of; end
  def inverse_of=(_arg0); end
  def name; end
  def name=(_arg0); end
  def option_verifier; end
  def subject; end
  def subject=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::JoinTableMatcher
  def initialize(association_matcher, reflector); end

  def associated_class(*_arg0, &_arg1); end
  def association_foreign_key(*_arg0, &_arg1); end
  def connection(*_arg0, &_arg1); end
  def failure_message; end
  def foreign_key(*_arg0, &_arg1); end
  def join_table_exists?; end
  def join_table_has_correct_columns?; end
  def join_table_name(*_arg0, &_arg1); end
  def join_table_option_correct?; end
  def matches?(_subject); end
  def missing_option; end
  def model_class(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def option_verifier(*_arg0, &_arg1); end
  def options(*_arg0, &_arg1); end

  protected

  def association_matcher; end
  def reflector; end

  private

  def actual_join_table_columns; end
  def column_label; end
  def expected_join_table_columns; end
  def missing_columns; end
  def missing_columns_message; end
  def missing_table_message; end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflection < ::SimpleDelegator
  def initialize(reflection); end

  def associated_class; end
  def association_foreign_key; end
  def association_relation(related_instance); end
  def foreign_key; end
  def has_and_belongs_to_many_name; end
  def join_table_name; end
  def polymorphic?; end
  def through?; end
  def validate_inverse_of_through_association!; end

  protected

  def reflection; end
  def subject; end

  private

  def has_and_belongs_to_many_name_table_name; end
  def has_and_belongs_to_many_reflection; end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflector
  def initialize(subject, name); end

  def associated_class(*_arg0, &_arg1); end
  def association_foreign_key(*_arg0, &_arg1); end
  def association_relation; end
  def build_relation_with_clause(name, value); end
  def extract_relation_clause_from(relation, name); end
  def foreign_key(*_arg0, &_arg1); end
  def has_and_belongs_to_many_name(*_arg0, &_arg1); end
  def join_table_name(*_arg0, &_arg1); end
  def model_class; end
  def polymorphic?(*_arg0, &_arg1); end
  def reflect_on_association(name); end
  def reflection; end
  def through?(*_arg0, &_arg1); end
  def validate_inverse_of_through_association!(*_arg0, &_arg1); end

  protected

  def name; end
  def subject; end
  def value_as_sql(value); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier
  def initialize(reflector); end

  def actual_value_for(name); end
  def correct_for?(*args); end
  def correct_for_boolean?(name, expected_value); end
  def correct_for_constant?(name, expected_unresolved_value); end
  def correct_for_hash?(name, expected_value); end
  def correct_for_relation_clause?(name, expected_value); end
  def correct_for_string?(name, expected_value); end
  def reflection(*_arg0, &_arg1); end

  protected

  def actual_value_for_class_name; end
  def actual_value_for_option(name); end
  def actual_value_for_relation_clause(name); end
  def expected_value_for(type, name, value); end
  def expected_value_for_constant(name); end
  def expected_value_for_relation_clause(name, value); end
  def reflector; end
  def type_cast(type, value); end
end

Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier::DEFAULT_VALUE_OF_OPTIONS = T.let(T.unsafe(nil), Hash)
Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier::RELATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionalMatcher
  def initialize(attribute_name, optional); end

  def description; end
  def matches?(subject); end
  def missing_option; end

  private

  def attribute_name; end
  def optional; end
  def submatcher; end
  def submatcher_passes?(subject); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OrderMatcher
  def initialize(order, name); end

  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end

  protected

  def name; end
  def name=(_arg0); end
  def option_verifier; end
  def order; end
  def order=(_arg0); end
  def subject; end
  def subject=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::RequiredMatcher
  def initialize(attribute_name, required); end

  def description; end
  def matches?(subject); end
  def missing_option; end

  private

  def attribute_name; end
  def required; end
  def submatcher; end
  def submatcher_passes?(subject); end
  def validation_message_key; end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::SourceMatcher
  def initialize(source, name); end

  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end

  protected

  def name; end
  def name=(_arg0); end
  def option_verifier; end
  def source; end
  def source=(_arg0); end
  def subject; end
  def subject=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ThroughMatcher
  def initialize(through, name); end

  def association_set_properly?; end
  def description; end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(_arg0); end
  def through_association_correct?; end
  def through_association_exists?; end
  def through_reflection; end

  protected

  def name; end
  def name=(_arg0); end
  def option_verifier; end
  def subject; end
  def subject=(_arg0); end
  def through; end
  def through=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::DefineEnumForMatcher
  def initialize(attribute_name); end

  def backed_by_column_of_type(expected_column_type); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end
  def with(expected_enum_values); end
  def with_prefix(expected_prefix = T.unsafe(nil)); end
  def with_suffix(expected_suffix = T.unsafe(nil)); end
  def with_values(expected_enum_values); end

  private

  def actual_enum_values; end
  def attribute_name; end
  def column; end
  def column_type_matches?; end
  def enum_defined?; end
  def enum_value_methods_exist?; end
  def enum_values_match?; end
  def expectation; end
  def expected_column_type; end
  def expected_enum_value_names; end
  def expected_enum_values; end
  def expected_prefix; end
  def expected_singleton_methods; end
  def expected_suffix; end
  def failure_message_continuation; end
  def model; end
  def normalized_actual_enum_values; end
  def normalized_expected_enum_values; end
  def options; end
  def presented_enum_mapping(enum_values); end
  def record; end
  def simple_description; end
  def to_array(value); end
  def to_hash(value); end
end

class Shoulda::Matchers::ActiveRecord::HaveAttachedMatcher
  def initialize(macro, name); end

  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end
  def name; end

  private

  def attachments_association_exists?; end
  def attachments_association_matcher; end
  def attachments_association_name; end
  def blobs_association_exists?; end
  def blobs_association_matcher; end
  def blobs_association_name; end
  def eager_loading_scope_exists?; end
  def macro; end
  def model_class; end
  def reader_attribute_exists?; end
  def subject; end
  def writer_attribute_exists?; end
end

class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher
  def initialize(column); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end
  def of_type(column_type); end
  def with_options(opts = T.unsafe(nil)); end

  protected

  def actual_primary?; end
  def actual_scale; end
  def column_exists?; end
  def correct_column_type?; end
  def correct_default?; end
  def correct_limit?; end
  def correct_null?; end
  def correct_precision?; end
  def correct_primary?; end
  def correct_scale?; end
  def expectation; end
  def matched_column; end
  def model_class; end
  def validate_options(opts); end
end

class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::DecoratedColumn < ::SimpleDelegator
  def initialize(model, column); end

  def primary?; end
  def type_cast_default; end

  protected

  def model; end
end

Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::OPTIONS = T.let(T.unsafe(nil), Array)

class Shoulda::Matchers::ActiveRecord::HaveDbIndexMatcher
  def initialize(columns); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end
  def unique(unique = T.unsafe(nil)); end

  private

  def actual_indexes; end
  def correct_unique?; end
  def described_table_name; end
  def expected_columns; end
  def formatted_expected_columns; end
  def index_exists?; end
  def index_type; end
  def inspected_expected_columns; end
  def matched_index; end
  def model; end
  def negative_expectation; end
  def normalize_columns_to_array(columns); end
  def positive_expectation; end
  def qualifiers; end
  def reason; end
  def subject; end
  def table_name; end
end

class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher
  def initialize(column_name); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end

  private

  def check_column_exists!; end
  def check_implicit_order_column_matches!; end
  def column_name; end
  def expectation; end
  def model; end
  def subject; end
end

class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::PrimaryCheckFailedError < ::StandardError; end
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::SecondaryCheckFailedError < ::StandardError; end

class Shoulda::Matchers::ActiveRecord::HaveReadonlyAttributeMatcher
  def initialize(attribute); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end

  private

  def class_name; end
  def readonly_attributes; end
end

class Shoulda::Matchers::ActiveRecord::HaveRichTextMatcher
  def initialize(rich_text_attribute); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end

  private

  def error; end
  def error_description; end
  def has_attribute?; end
  def has_expected_action_text?; end
  def rich_text_attribute; end
  def run_checks; end
  def subject; end
end

class Shoulda::Matchers::ActiveRecord::HaveSecureTokenMatcher
  def initialize(token_attribute); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def ignoring_check_for_db_index; end
  def matches?(subject); end
  def token_attribute; end

  private

  def has_expected_db_column?; end
  def has_expected_db_index?; end
  def has_expected_instance_methods?; end
  def run_checks; end
  def table_and_column; end
  def table_name; end
end

class Shoulda::Matchers::ActiveRecord::SerializeMatcher
  def initialize(name); end

  def as(type); end
  def as_instance_of(type); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject); end

  protected

  def attribute_is_serialized?; end
  def class_valid?; end
  def expectation; end
  def instance_class_valid?; end
  def model; end
  def model_class; end
  def serialization_coder; end
  def serialization_valid?; end
  def type_valid?; end
end

module Shoulda::Matchers::ActiveRecord::Uniqueness; end

class Shoulda::Matchers::ActiveRecord::Uniqueness::Model
  def initialize(name, namespace); end

  def already_exists?; end
  def next; end
  def symlink_to(parent); end
  def to_s; end

  protected

  def name; end
  def namespace; end

  class << self
    def next_unique_copy_of(model_name, namespace); end
  end
end

class Shoulda::Matchers::ActiveRecord::Uniqueness::Namespace
  def initialize(constant); end

  def clear; end
  def has?(name); end
  def set(name, value); end
  def to_s; end

  protected

  def constant; end
end

class Shoulda::Matchers::ActiveRecord::Uniqueness::TestModelCreator
  def initialize(model_name, namespace); end

  def create; end

  protected

  def model_name; end
  def namespace; end

  private

  def existing_model; end
  def model_name_without_namespace; end
  def new_model; end

  class << self
    def create(model_name, namespace); end
  end
end

module Shoulda::Matchers::ActiveRecord::Uniqueness::TestModels
  class << self
    def create(model_name); end
    def remove_all; end
    def root_namespace; end
  end
end

class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  def initialize(attribute); end

  def allow_blank; end
  def allow_nil; end
  def case_insensitive; end
  def does_not_match?(given_record); end
  def expects_to_allow_blank?; end
  def expects_to_allow_nil?; end
  def ignoring_case_sensitivity; end
  def matches?(given_record); end
  def scoped_to(*scopes); end
  def simple_description; end

  protected

  def build_allow_or_disallow_value_matcher(args); end
  def failure_reason; end
  def failure_reason_when_negated; end

  private

  def actual_sets_of_scopes; end
  def all_scopes_are_booleans?; end
  def arbitrary_non_blank_value; end
  def attribute_changed_value_message; end
  def attribute_names_under_test; end
  def attribute_present_on_model?; end
  def attribute_setter_descriptions_for_new_record; end
  def attribute_setter_for_existing_record; end
  def attribute_setters_for_new_record; end
  def available_enum_values_for(scope, previous_value); end
  def boolean_value?(value); end
  def build_attribute_setter(record, attribute_name, value); end
  def build_new_record; end
  def case_sensitivity_strategy; end
  def column_for(scope); end
  def column_limit_for(attribute); end
  def create_existing_record; end
  def defined_as_enum?(scope); end
  def description_for_attribute_setter(attribute_setter, same_as_existing: T.unsafe(nil)); end
  def description_for_case_sensitive_qualifier; end
  def descriptions_for_attribute_setters_for_new_record; end
  def does_not_match_allow_blank?; end
  def does_not_match_allow_nil?; end
  def does_not_match_presence_of_attribute?; end
  def does_not_match_presence_of_scopes?; end
  def does_not_match_scopes_configuration?; end
  def does_not_match_uniqueness_with_case_sensitivity_strategy?; end
  def does_not_match_uniqueness_with_scopes?; end
  def does_not_match_uniqueness_without_scopes?; end
  def dummy_scalar_value_for(column); end
  def dummy_value_for(scope); end
  def existing_and_new_values_are_same?; end
  def existing_record; end
  def existing_value_read; end
  def existing_value_written; end
  def expected_scopes; end
  def failure_message_preface; end
  def find_existing_record; end
  def find_or_create_existing_record; end
  def has_secure_password?; end
  def inspected_actual_scopes; end
  def inspected_actual_sets_of_scopes; end
  def inspected_expected_scopes; end
  def last_attribute_setter_used_on_new_record; end
  def last_value_set_on_new_record; end
  def matches_allow_blank?; end
  def matches_allow_nil?; end
  def matches_presence_of_attribute?; end
  def matches_presence_of_scopes?; end
  def matches_scopes_configuration?; end
  def matches_uniqueness_with_case_sensitivity_strategy?; end
  def matches_uniqueness_with_scopes?; end
  def matches_uniqueness_without_scopes?; end
  def model; end
  def model_class?(model_name); end
  def new_record; end
  def next_scalar_value_for(scope, previous_value); end
  def next_value_for(scope, previous_value); end
  def polymorphic_type_attribute?(scope, previous_value); end
  def scopes_match?; end
  def scopes_missing_on_model; end
  def scopes_present_on_model; end
  def set_attribute_on!(record_type, record, attribute_name, value); end
  def set_attribute_on_existing_record!(attribute_name, value); end
  def set_attribute_on_new_record!(attribute_name, value); end
  def setting_next_value_for(scope); end
  def should_test_case_sensitivity?; end
  def subject; end
  def update_existing_record!(value); end
  def validations; end
end

class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::AttributeSetters
  include ::Enumerable

  def initialize; end

  def +(other_attribute_setters); end
  def <<(given_attribute_setter); end
  def each(&block); end
  def last; end

  private

  def find_index_of(given_attribute_setter); end
end

class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::ExistingRecordInvalid < ::Shoulda::Matchers::Error
  include ::Shoulda::Matchers::ActiveModel::Helpers

  def message; end
  def underlying_exception; end
  def underlying_exception=(_arg0); end
end

class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::NonCaseSwappableValueError < ::Shoulda::Matchers::Error
  def attribute; end
  def attribute=(_arg0); end
  def message; end
  def model; end
  def model=(_arg0); end
  def value; end
  def value=(_arg0); end
end

class Shoulda::Matchers::Configuration
  def initialize; end

  def integrate(&block); end
  def integrations; end
end

class Shoulda::Matchers::Document
  def initialize(document, indent: T.unsafe(nil)); end

  def wrap; end

  protected

  def document; end
  def indent; end

  private

  def paragraphs; end
  def wrapped_paragraphs; end
end

module Shoulda::Matchers::Doublespeak
  class << self
    def debug(&block); end
    def debugging_enabled?; end
    def double_collection_for(*args, &block); end
    def with_doubles_activated(*args, &block); end
    def world; end
  end
end

class Shoulda::Matchers::Doublespeak::Double
  def initialize(world, klass, method_name, implementation); end

  def activate; end
  def activated?; end
  def call_original_method(call); end
  def calls; end
  def deactivate; end
  def record_call(call); end
  def to_return(value = T.unsafe(nil), &block); end

  protected

  def implementation; end
  def klass; end
  def method_name; end
  def original_method; end
  def replace_method_with_double; end
  def restore_original_method; end
  def store_original_method; end
  def world; end
end

class Shoulda::Matchers::Doublespeak::DoubleCollection
  def initialize(world, klass); end

  def activate; end
  def calls_by_method_name; end
  def calls_to(method_name); end
  def deactivate; end
  def register_proxy(method_name); end
  def register_stub(method_name); end

  protected

  def doubles_by_method_name; end
  def klass; end
  def register_double(method_name, implementation_type); end
  def world; end
end

module Shoulda::Matchers::Doublespeak::DoubleImplementationRegistry
  class << self
    def find(type); end
    def register(klass, type); end

    private

    def find_class!(type); end
    def registry; end
  end
end

class Shoulda::Matchers::Doublespeak::MethodCall
  def initialize(args); end

  def ==(other); end
  def args; end
  def block; end
  def caller; end
  def double; end
  def inspect; end
  def method_name; end
  def object; end
  def return_value; end
  def return_value=(_arg0); end
  def to_hash; end
  def with_return_value(return_value); end
end

class Shoulda::Matchers::Doublespeak::ObjectDouble < ::BasicObject
  def initialize; end

  def calls; end
  def calls_to(method_name); end
  def method_missing(method_name, *args, &block); end
  def respond_to?(_name, _include_private = T.unsafe(nil)); end

  protected

  def calls_by_method_name; end

  private

  def respond_to_missing?(_name, _include_all); end
end

class Shoulda::Matchers::Doublespeak::ProxyImplementation
  extend ::Forwardable

  def initialize(stub_implementation); end

  def call(call); end
  def returns(*args, &block); end

  protected

  def stub_implementation; end

  class << self
    def create; end
  end
end

class Shoulda::Matchers::Doublespeak::StubImplementation
  def initialize; end

  def call(call); end
  def returns(value = T.unsafe(nil), &block); end

  protected

  def implementation; end

  class << self
    def create; end
  end
end

class Shoulda::Matchers::Doublespeak::World
  def initialize; end

  def double_collection_for(klass); end
  def doubles_activated?; end
  def original_method_for(klass, method_name); end
  def store_original_method_for(klass, method_name); end
  def with_doubles_activated; end

  private

  def activate; end
  def deactivate; end
  def double_collections_by_class; end
  def original_methods_by_class; end
  def original_methods_for_class(klass); end
end

class Shoulda::Matchers::Error < ::StandardError
  def initialize(*args); end

  def inspect; end
  def message; end

  class << self
    def create(attributes); end
  end
end

module Shoulda::Matchers::Independent
  def delegate_method(delegating_method); end
end

class Shoulda::Matchers::Independent::DelegateMethodMatcher
  def initialize(delegating_method); end

  def allow_nil; end
  def as(delegate_method); end
  def build_delegating_method_prefix(prefix); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def matches?(subject); end
  def to(delegate_object_reader_method); end
  def with_arguments(*arguments); end
  def with_prefix(prefix = T.unsafe(nil)); end

  protected

  def call_delegating_method_with_delegate_method_returning(value); end
  def calls_on_delegate_object; end
  def calls_to_delegate_method; end
  def class_or_instance_method_indicator; end
  def class_under_test; end
  def context; end
  def delegate_method; end
  def delegate_object; end
  def delegate_object_reader_method; end
  def delegate_object_received_call?; end
  def delegate_object_received_call_with_delegated_arguments?; end
  def delegated_arguments; end
  def delegating_method; end
  def ensure_delegate_object_has_been_specified!; end
  def expects_to_allow_nil_delegate_object?; end
  def failed_to_allow_nil_delegate_object?; end
  def formatted_calls_on_delegate_object; end
  def formatted_delegate_method(options = T.unsafe(nil)); end
  def formatted_delegate_object_reader_method_name(options = T.unsafe(nil)); end
  def formatted_delegating_method_name(options = T.unsafe(nil)); end
  def formatted_method_name_for(method_name, options); end
  def method; end
  def possible_class_under_test(options); end
  def register_subject_double_collection_to(returned_value); end
  def subject; end
  def subject_delegates_to_delegate_object_correctly?; end
  def subject_handles_nil_delegate_object?; end
  def subject_has_delegate_object_reader_method?; end
  def subject_has_delegating_method?; end
  def subject_is_a_class?; end
end

class Shoulda::Matchers::Independent::DelegateMethodMatcher::DelegateObjectNotSpecified < ::StandardError
  def message; end
end

module Shoulda::Matchers::Integrations
  class << self
    def find_library!(name); end
    def find_test_framework!(name); end
    def register_library(klass, name); end
    def register_test_framework(klass, name); end

    private

    def library_registry; end
    def test_framework_registry; end
  end
end

class Shoulda::Matchers::Integrations::Configuration
  def initialize(&block); end

  def apply; end
  def library(name); end
  def test_framework(name); end
  def test_frameworks; end

  private

  def clear_default_test_framework; end
  def no_libraries_added?; end
  def no_test_frameworks_added?; end

  class << self
    def apply(&block); end
  end
end

class Shoulda::Matchers::Integrations::ConfigurationError < ::StandardError; end

module Shoulda::Matchers::Integrations::Inclusion
  def include_into(mod, *other_mods, &block); end
end

module Shoulda::Matchers::Integrations::Libraries; end

class Shoulda::Matchers::Integrations::Libraries::ActionController
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  def integrate_with(test_framework); end

  private

  def matchers_module; end
end

class Shoulda::Matchers::Integrations::Libraries::ActiveModel
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  def integrate_with(test_framework); end

  private

  def matchers_module; end
end

class Shoulda::Matchers::Integrations::Libraries::ActiveRecord
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  def integrate_with(test_framework); end

  private

  def matchers_module; end
end

class Shoulda::Matchers::Integrations::Libraries::MissingLibrary
  def integrate_with(test_framework); end
  def rails?; end
end

class Shoulda::Matchers::Integrations::Libraries::Rails
  include ::Shoulda::Matchers::Integrations::Rails

  def integrate_with(test_framework); end
end

Shoulda::Matchers::Integrations::Libraries::Rails::SUB_LIBRARIES = T.let(T.unsafe(nil), Array)

class Shoulda::Matchers::Integrations::Libraries::Routing
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  def integrate_with(test_framework); end

  private

  def matchers_module; end
end

module Shoulda::Matchers::Integrations::Rails
  def rails?; end
end

class Shoulda::Matchers::Integrations::Registry
  def find!(name); end
  def register(klass, name); end

  private

  def find_class!(name); end
  def registry; end
end

module Shoulda::Matchers::Integrations::TestFrameworks; end

class Shoulda::Matchers::Integrations::TestFrameworks::ActiveSupportTestCase
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def validate!; end

  protected

  def configuration; end

  private

  def test_case_class; end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Minitest4
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def validate!; end

  private

  def test_case_class; end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Minitest5
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def validate!; end

  private

  def test_case_class; end
end

class Shoulda::Matchers::Integrations::TestFrameworks::MissingTestFramework
  def include(*modules, **options); end
  def n_unit?; end
  def present?; end
  def validate!; end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Rspec
  def include(*modules, **options); end
  def n_unit?; end
  def present?; end
  def validate!; end
end

class Shoulda::Matchers::Integrations::TestFrameworks::TestUnit
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def validate!; end

  private

  def test_case_class; end
end

class Shoulda::Matchers::Line
  def initialize(line, indent: T.unsafe(nil)); end

  def wrap; end

  protected

  def indent; end
  def indentation; end
  def line_to_wrap; end
  def original_line; end
  def previous_line_to_wrap; end

  private

  def determine_where_to_break_line(line, args); end
  def normalize_whitespace(string); end
  def read_indentation; end
  def wrap_line(line); end
end

Shoulda::Matchers::Line::OFFSETS = T.let(T.unsafe(nil), Hash)

class Shoulda::Matchers::MatcherContext
  def initialize(context); end

  def subject_is_a_class?; end

  protected

  def context; end

  private

  def assume_that_subject_is_not_a_class; end
  def inside_a_shoulda_context_project?; end
  def outside_a_should_block?; end
end

class Shoulda::Matchers::Paragraph
  def initialize(paragraph, indent: T.unsafe(nil)); end

  def wrap; end

  protected

  def indent; end
  def paragraph; end

  private

  def combine_list_item_lines(lines); end
  def combine_paragraph_into_one_line; end
  def lines; end
  def wrap_generic_paragraph; end
  def wrap_lines(lines); end
  def wrap_list_item; end
end

module Shoulda::Matchers::RailsShim
  class << self
    def action_pack_version; end
    def active_record_gte_6?; end
    def active_record_version; end
    def attribute_serialization_coder_for(model, attribute_name); end
    def attribute_type_for(model, attribute_name); end
    def attribute_types_for(model); end
    def digestible_attributes_in(record); end
    def generate_validation_message(record, attribute, type, model_name, options); end
    def has_secure_password?(record, attribute_name); end
    def parent_of(mod); end
    def secure_password_module; end
    def serialized_attributes_for(model); end
    def supports_full_attributes_api?(model); end
    def verb_for_update; end

    private

    def simply_generate_validation_message(attribute, type, model_name, options); end
  end
end

module Shoulda::Matchers::Routing
  def route(method, path, port: T.unsafe(nil)); end
end

Shoulda::Matchers::TERMINAL_MAX_WIDTH = T.let(T.unsafe(nil), Integer)

class Shoulda::Matchers::Text < ::String
  def indented?; end
  def list_item?; end
  def match_as_list_item; end
end

Shoulda::Matchers::Text::LIST_ITEM_REGEXP = T.let(T.unsafe(nil), Regexp)

module Shoulda::Matchers::Util
  class << self
    def a_or_an(next_word); end
    def deconstantize(path); end
    def dummy_value_for(column_type, array: T.unsafe(nil)); end
    def indent(string, width); end
    def inspect_hash(hash); end
    def inspect_range(range); end
    def inspect_value(value); end
    def inspect_values(values); end
    def safe_constantize(camel_cased_word); end
  end
end

Shoulda::Matchers::Util::MAXIMUM_LENGTH_OF_VALUE_TO_DISPLAY = T.let(T.unsafe(nil), Integer)
Shoulda::Matchers::VERSION = T.let(T.unsafe(nil), String)

module Shoulda::Matchers::WordWrap
  def word_wrap(document, options = T.unsafe(nil)); end
end

Shoulda::Matchers::WordWrap::TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)
