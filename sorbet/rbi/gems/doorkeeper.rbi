# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/doorkeeper/all/doorkeeper.rbi
#
# doorkeeper-5.2.2
module Doorkeeper
  def self.authenticate(request, methods = nil); end
  def self.configuration; end
  def self.configure(&block); end
  def self.gem_version; end
  def self.setup_application_owner; end
  def self.setup_orm_adapter; end
  def self.setup_orm_models; end
end
module Doorkeeper::VERSION
end
class Doorkeeper::Engine < Rails::Engine
end
class Doorkeeper::Config
  def access_token_expires_in(*_args); end
  def access_token_generator(*_args); end
  def access_token_methods; end
  def active_record_options(*_args); end
  def after_successful_authorization(*_args); end
  def after_successful_strategy_response(*_args); end
  def allow_blank_redirect_uri(*_args); end
  def allow_blank_redirect_uri?(application = nil); end
  def allow_grant_flow_for_client(*_args); end
  def allow_grant_flow_for_client?(grant_flow, client); end
  def allow_token_introspection(*_args); end
  def api_only; end
  def application_secret_fallback_strategy; end
  def application_secret_strategy; end
  def authenticate_admin(*_args); end
  def authenticate_resource_owner(*_args); end
  def authorization_code_expires_in(*_args); end
  def authorization_response_types; end
  def base_controller(*_args); end
  def base_metal_controller(*_args); end
  def before_successful_authorization(*_args); end
  def before_successful_strategy_response(*_args); end
  def calculate_authorization_response_types; end
  def calculate_token_grant_types; end
  def client_credentials_methods; end
  def confirm_application_owner?; end
  def custom_access_token_expires_in(*_args); end
  def custom_introspection_response(*_args); end
  def default_generator_method(*_args); end
  def default_scopes; end
  def enable_application_owner?; end
  def enforce_configured_scopes?; end
  def enforce_content_type; end
  def forbid_redirect_uri(*_args); end
  def force_ssl_in_redirect_uri(*_args); end
  def grant_flows(*_args); end
  def handle_auth_errors(*_args); end
  def native_redirect_uri(*_args); end
  def option_defined?(name); end
  def option_set?(instance_key); end
  def optional_scopes; end
  def orm(*_args); end
  def raise_on_errors?; end
  def realm(*_args); end
  def refresh_token_enabled?; end
  def resolve_controller(name); end
  def resource_owner_from_credentials(*_args); end
  def reuse_access_token; end
  def scopes; end
  def scopes_by_grant_type; end
  def skip_authorization(*_args); end
  def token_grant_types; end
  def token_reuse_limit; end
  def token_secret_fallback_strategy; end
  def token_secret_strategy; end
  def validate; end
  def validate_reuse_access_token_value; end
  def validate_secret_strategies; end
  def validate_token_reuse_limit; end
  extend Doorkeeper::Config::Option
end
module Doorkeeper::Config::Option
  def option(name, options = nil); end
end
class Doorkeeper::MissingConfiguration < StandardError
  def initialize; end
end
class Doorkeeper::Config::Builder
  def access_token_expires_in(*args, &block); end
  def access_token_generator(*args, &block); end
  def access_token_methods(*methods); end
  def active_record_options(*args, &block); end
  def admin_authenticator(*args, &block); end
  def after_successful_authorization(*args, &block); end
  def after_successful_strategy_response(*args, &block); end
  def allow_blank_redirect_uri(*args, &block); end
  def allow_grant_flow_for_client(*args, &block); end
  def allow_token_introspection(*args, &block); end
  def api_only; end
  def authorization_code_expires_in(*args, &block); end
  def base_controller(*args, &block); end
  def base_metal_controller(*args, &block); end
  def before_successful_authorization(*args, &block); end
  def before_successful_strategy_response(*args, &block); end
  def build; end
  def client_credentials(*methods); end
  def configure_secrets_for(type, using:, fallback:); end
  def confirm_application_owner; end
  def custom_access_token_expires_in(*args, &block); end
  def custom_introspection_response(*args, &block); end
  def default_generator_method(*args, &block); end
  def default_scopes(*scopes); end
  def enable_application_owner(opts = nil); end
  def enforce_configured_scopes; end
  def enforce_content_type; end
  def forbid_redirect_uri(*args, &block); end
  def force_ssl_in_redirect_uri(*args, &block); end
  def grant_flows(*args, &block); end
  def handle_auth_errors(*args, &block); end
  def hash_application_secrets(using: nil, fallback: nil); end
  def hash_token_secrets(using: nil, fallback: nil); end
  def initialize(&block); end
  def native_redirect_uri(*_, &_); end
  def optional_scopes(*scopes); end
  def orm(*args, &block); end
  def realm(*args, &block); end
  def resource_owner_authenticator(*args, &block); end
  def resource_owner_from_credentials(*args, &block); end
  def reuse_access_token; end
  def scopes_by_grant_type(hash = nil); end
  def skip_authorization(*args, &block); end
  def token_reuse_limit(percentage); end
  def use_refresh_token(enabled = nil, &block); end
end
module Doorkeeper::Request
  def self.authorization_strategy(response_type); end
  def self.build_strategy_class(grant_or_request_type); end
  def self.get_strategy(grant_type, available); end
  def self.token_grant_types; end
  def self.token_strategy(grant_type); end
end
class Doorkeeper::Request::Strategy
  def authorize(*args, &block); end
  def initialize(server); end
  def request; end
  def server; end
  def server=(arg0); end
end
class Doorkeeper::Request::AuthorizationCode < Doorkeeper::Request::Strategy
  def client(*args, &block); end
  def grant; end
  def parameters(*args, &block); end
  def request; end
end
class Doorkeeper::Request::ClientCredentials < Doorkeeper::Request::Strategy
  def client(*args, &block); end
  def parameters(*args, &block); end
  def request; end
end
class Doorkeeper::Request::Code < Doorkeeper::Request::Strategy
  def current_resource_owner(*args, &block); end
  def pre_auth; end
  def request; end
end
class Doorkeeper::Request::Password < Doorkeeper::Request::Strategy
  def client(*args, &block); end
  def credentials(*args, &block); end
  def parameters(*args, &block); end
  def request; end
  def resource_owner(*args, &block); end
end
class Doorkeeper::Request::RefreshToken < Doorkeeper::Request::Strategy
  def credentials(*args, &block); end
  def parameters(*args, &block); end
  def refresh_token; end
  def request; end
end
class Doorkeeper::Request::Token < Doorkeeper::Request::Strategy
  def current_resource_owner(*args, &block); end
  def pre_auth; end
  def request; end
end
module Doorkeeper::Errors
end
class Doorkeeper::Errors::DoorkeeperError < StandardError
  def type; end
end
class Doorkeeper::Errors::InvalidGrantReuse < Doorkeeper::Errors::DoorkeeperError
  def type; end
end
class Doorkeeper::Errors::InvalidTokenStrategy < Doorkeeper::Errors::DoorkeeperError
  def type; end
end
class Doorkeeper::Errors::MissingRequiredParameter < Doorkeeper::Errors::DoorkeeperError
  def initialize(missing_param); end
  def missing_param; end
  def type; end
end
class Doorkeeper::Errors::BaseResponseError < Doorkeeper::Errors::DoorkeeperError
  def initialize(response); end
  def response; end
end
class Doorkeeper::Errors::UnableToGenerateToken < Doorkeeper::Errors::DoorkeeperError
end
class Doorkeeper::Errors::TokenGeneratorNotFound < Doorkeeper::Errors::DoorkeeperError
end
class Doorkeeper::Errors::NoOrmCleaner < Doorkeeper::Errors::DoorkeeperError
end
class Doorkeeper::Errors::InvalidToken < Doorkeeper::Errors::BaseResponseError
end
class Doorkeeper::Errors::TokenExpired < Doorkeeper::Errors::InvalidToken
end
class Doorkeeper::Errors::TokenRevoked < Doorkeeper::Errors::InvalidToken
end
class Doorkeeper::Errors::TokenUnknown < Doorkeeper::Errors::InvalidToken
end
class Doorkeeper::Errors::TokenForbidden < Doorkeeper::Errors::InvalidToken
end
class Doorkeeper::Server
  def authorization_request(strategy); end
  def client; end
  def context; end
  def context=(arg0); end
  def credentials; end
  def current_resource_owner; end
  def initialize(context = nil); end
  def parameters; end
  def resource_owner; end
  def token_request(strategy); end
end
module Doorkeeper::Validations
  def error; end
  def error=(arg0); end
  def valid?; end
  def validate; end
  extend ActiveSupport::Concern
end
module Doorkeeper::Validations::ClassMethods
  def validate(attribute, options = nil); end
  def validations; end
end
module Doorkeeper::OAuth
end
module Doorkeeper::OAuth::Authorization
end
class Doorkeeper::OAuth::Authorization::Code
  def access_grant_attributes; end
  def authorization_code_expires_in; end
  def initialize(pre_auth, resource_owner); end
  def issue_token; end
  def oob_redirect; end
  def pkce_attributes; end
  def pkce_supported?; end
  def pre_auth; end
  def pre_auth=(arg0); end
  def resource_owner; end
  def resource_owner=(arg0); end
  def token; end
  def token=(arg0); end
end
class Doorkeeper::OAuth::Authorization::Context
  def client; end
  def grant_type; end
  def initialize(client, grant_type, scopes); end
  def scopes; end
end
class Doorkeeper::OAuth::Authorization::Token
  def configuration; end
  def controller; end
  def initialize(pre_auth, resource_owner); end
  def issue_token; end
  def oob_redirect; end
  def pre_auth; end
  def pre_auth=(arg0); end
  def resource_owner; end
  def resource_owner=(arg0); end
  def self.access_token_expires_in(configuration, context); end
  def self.build_context(pre_auth_or_oauth_client, grant_type, scopes); end
  def self.refresh_token_enabled?(server, context); end
  def token; end
  def token=(arg0); end
end
class Doorkeeper::OAuth::Authorization::URIBuilder
  def self.build_query(parameters = nil); end
  def self.uri_with_fragment(url, parameters = nil); end
  def self.uri_with_query(url, parameters = nil); end
end
module Doorkeeper::OAuth::Helpers
end
module Doorkeeper::OAuth::Helpers::ScopeChecker
  def self.valid?(scope_str:, server_scopes:, app_scopes: nil, grant_type: nil); end
end
class Doorkeeper::OAuth::Helpers::ScopeChecker::Validator
  def initialize(scope_str, server_scopes, app_scopes, grant_type); end
  def parsed_scopes; end
  def permitted_to_grant_type?; end
  def scope_str; end
  def valid?; end
  def valid_scopes(server_scopes, app_scopes); end
end
module Doorkeeper::IPAddrLoopback
  def loopback?; end
end
module Doorkeeper::OAuth::Helpers::URIChecker
  def self.as_uri(url); end
  def self.hypertext_scheme?(uri); end
  def self.iff_host?(uri); end
  def self.loopback_uri?(uri); end
  def self.matches?(url, client_url); end
  def self.oob_uri?(uri); end
  def self.query_matches?(query, client_query); end
  def self.valid?(url); end
  def self.valid_for_authorization?(url, client_url); end
  def self.valid_scheme?(uri); end
end
module Doorkeeper::OAuth::Helpers::UniqueToken
  def self.generate(options = nil); end
  def self.generator_method; end
end
class Doorkeeper::OAuth::Scopes
  def &(other); end
  def +(other); end
  def <=>(other); end
  def add(*scopes); end
  def all; end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def exists?(scope); end
  def has_scopes?(scopes); end
  def initialize; end
  def scopes?(scopes); end
  def self.from_array(array); end
  def self.from_string(string); end
  def to_array(other); end
  def to_s; end
  include Comparable
  include Enumerable
end
class Doorkeeper::OAuth::Error < Struct
  def description; end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def state; end
  def state=(_); end
end
class Doorkeeper::OAuth::BaseResponse
  def body; end
  def description; end
  def headers; end
  def redirect_uri; end
  def redirectable?; end
  def status; end
end
class Doorkeeper::OAuth::CodeResponse < Doorkeeper::OAuth::BaseResponse
  def auth; end
  def auth=(arg0); end
  def initialize(pre_auth, auth, options = nil); end
  def pre_auth; end
  def pre_auth=(arg0); end
  def redirect_uri; end
  def redirectable?; end
  def response_on_fragment; end
  def response_on_fragment=(arg0); end
  include Doorkeeper::OAuth::Helpers
end
class Doorkeeper::OAuth::TokenResponse
  def body; end
  def headers; end
  def initialize(token); end
  def status; end
  def token; end
  def token=(arg0); end
end
class Doorkeeper::OAuth::ErrorResponse < Doorkeeper::OAuth::BaseResponse
  def authenticate_info; end
  def body; end
  def configuration; end
  def description(*args, &block); end
  def exception_class; end
  def headers; end
  def initialize(attributes = nil); end
  def name(*args, &block); end
  def raise_exception!; end
  def realm(*args, &block); end
  def redirect_uri; end
  def redirectable?; end
  def self.from_request(request, attributes = nil); end
  def state(*args, &block); end
  def status; end
  include Doorkeeper::OAuth::Helpers
end
class Doorkeeper::OAuth::PreAuthorization
  def as_json(attributes = nil); end
  def authorizable?; end
  def build_scopes; end
  def client; end
  def client_id; end
  def code_challenge; end
  def code_challenge_method; end
  def error_response; end
  def grant_type; end
  def initialize(server, attrs = nil); end
  def missing_param; end
  def pre_auth_hash; end
  def redirect_uri; end
  def response_type; end
  def scope; end
  def scopes; end
  def server; end
  def state; end
  def validate_client; end
  def validate_client_id; end
  def validate_client_supports_grant_flow; end
  def validate_code_challenge_method; end
  def validate_params; end
  def validate_redirect_uri; end
  def validate_response_type; end
  def validate_scopes; end
  extend Doorkeeper::Validations::ClassMethods
  include Doorkeeper::Validations
end
class Doorkeeper::OAuth::BaseRequest
  def after_successful_response; end
  def authorize; end
  def before_successful_response; end
  def build_scopes; end
  def default_scopes; end
  def find_or_create_access_token(client, resource_owner_id, scopes, server); end
  def grant_type; end
  def scopes; end
  def valid?; end
  extend Doorkeeper::Validations::ClassMethods
  include Doorkeeper::Validations
end
class Doorkeeper::OAuth::AuthorizationCodeRequest < Doorkeeper::OAuth::BaseRequest
  def access_token; end
  def access_token=(arg0); end
  def before_successful_response; end
  def client; end
  def client=(arg0); end
  def code_verifier; end
  def code_verifier=(arg0); end
  def grant; end
  def grant=(arg0); end
  def initialize(server, grant, client, parameters = nil); end
  def invalid_request_reason; end
  def missing_param; end
  def redirect_uri; end
  def redirect_uri=(arg0); end
  def server; end
  def server=(arg0); end
  def validate_client; end
  def validate_code_verifier; end
  def validate_grant; end
  def validate_params; end
  def validate_pkce_support; end
  def validate_redirect_uri; end
end
class Doorkeeper::OAuth::RefreshTokenRequest < Doorkeeper::OAuth::BaseRequest
  def access_token; end
  def access_token=(arg0); end
  def access_token_attributes; end
  def access_token_expires_in; end
  def before_successful_response; end
  def client; end
  def client=(arg0); end
  def create_access_token; end
  def credentials; end
  def credentials=(arg0); end
  def default_scopes; end
  def initialize(server, refresh_token, credentials, parameters = nil); end
  def load_client(credentials); end
  def missing_param; end
  def refresh_token; end
  def refresh_token=(arg0); end
  def refresh_token_revoked_on_use?; end
  def server; end
  def server=(arg0); end
  def validate_client; end
  def validate_client_match; end
  def validate_scope; end
  def validate_token; end
  def validate_token_presence; end
  include Doorkeeper::OAuth::Helpers
end
class Doorkeeper::OAuth::PasswordAccessTokenRequest < Doorkeeper::OAuth::BaseRequest
  def access_token; end
  def access_token=(arg0); end
  def before_successful_response; end
  def client; end
  def client=(arg0); end
  def initialize(server, client, resource_owner, parameters = nil); end
  def parameters; end
  def parameters=(arg0); end
  def resource_owner; end
  def resource_owner=(arg0); end
  def server; end
  def server=(arg0); end
  def validate_client; end
  def validate_client_supports_grant_flow; end
  def validate_resource_owner; end
  def validate_scopes; end
  include Doorkeeper::OAuth::Helpers
end
class Doorkeeper::OAuth::ClientCredentialsRequest < Doorkeeper::OAuth::BaseRequest
  def access_token; end
  def client; end
  def client=(arg0); end
  def error(*args, &block); end
  def error_response; end
  def initialize(server, client, parameters = nil); end
  def issuer; end
  def issuer=(arg0); end
  def original_scopes; end
  def original_scopes=(arg0); end
  def response; end
  def server; end
  def server=(arg0); end
  def valid?; end
end
class Doorkeeper::OAuth::ClientCredentialsRequest::Validation
  def initialize(server, request); end
  def validate_client; end
  def validate_client_supports_grant_flow; end
  def validate_scopes; end
  extend Doorkeeper::Validations::ClassMethods
  include Doorkeeper::OAuth::Helpers
  include Doorkeeper::Validations
end
class Doorkeeper::OAuth::ClientCredentialsRequest::Creator
  def call(client, scopes, attributes = nil); end
  def existing_token_for(client, scopes); end
end
class Doorkeeper::OAuth::ClientCredentialsRequest::Issuer
  def create(client, scopes, creator = nil); end
  def create_token(client, scopes, creator); end
  def error; end
  def error=(arg0); end
  def initialize(server, validation); end
  def token; end
  def token=(arg0); end
  def validation; end
  def validation=(arg0); end
end
class Doorkeeper::OAuth::Client
  def application; end
  def application=(arg0); end
  def id(*args, &block); end
  def initialize(application); end
  def name(*args, &block); end
  def redirect_uri(*args, &block); end
  def scopes(*args, &block); end
  def self.authenticate(credentials, method = nil); end
  def self.find(uid, method = nil); end
  def uid(*args, &block); end
end
class Doorkeeper::OAuth::Client::Credentials < Struct
  def blank?; end
  def secret; end
  def secret=(_); end
  def self.[](*arg0); end
  def self.from_basic(request); end
  def self.from_params(request); end
  def self.from_request(request, *credentials_methods); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def uid; end
  def uid=(_); end
end
class Doorkeeper::OAuth::CodeRequest
  def authorize; end
  def deny; end
  def initialize(pre_auth, resource_owner); end
  def pre_auth; end
  def pre_auth=(arg0); end
  def resource_owner; end
  def resource_owner=(arg0); end
end
class Doorkeeper::OAuth::TokenRequest
  def authorize; end
  def deny; end
  def initialize(pre_auth, resource_owner); end
  def pre_auth; end
  def pre_auth=(arg0); end
  def resource_owner; end
  def resource_owner=(arg0); end
end
class Doorkeeper::OAuth::Token
  def self.authenticate(request, *methods); end
  def self.decode_basic_credentials_token(encoded_header); end
  def self.from_access_token_param(request); end
  def self.from_basic_authorization(request); end
  def self.from_bearer_authorization(request); end
  def self.from_bearer_param(request); end
  def self.from_request(request, *methods); end
  def self.match?(header, pattern); end
  def self.token_from_basic_header(header, pattern); end
  def self.token_from_header(header, pattern); end
end
class Doorkeeper::OAuth::TokenIntrospection
  def active?; end
  def authorize!; end
  def authorized?; end
  def authorized_client; end
  def authorized_token; end
  def authorized_token_matches_introspected?; end
  def customize_response(response); end
  def error; end
  def error_response; end
  def failure_response; end
  def initialize(server, token); end
  def invalid_request_reason; end
  def server; end
  def success_response; end
  def to_json(*arg0); end
  def token; end
  def token_introspection_allowed?(auth_client: nil, auth_token: nil); end
  def valid_authorized_token?; end
  def valid_token?; end
end
class Doorkeeper::OAuth::InvalidTokenResponse < Doorkeeper::OAuth::ErrorResponse
  def description; end
  def errors_mapping; end
  def exception_class; end
  def initialize(attributes = nil); end
  def reason; end
  def self.from_access_token(access_token, attributes = nil); end
  def status; end
end
class Doorkeeper::OAuth::ForbiddenTokenResponse < Doorkeeper::OAuth::ErrorResponse
  def description; end
  def exception_class; end
  def headers; end
  def initialize(attributes = nil); end
  def self.from_scopes(scopes, attributes = nil); end
  def status; end
end
class Doorkeeper::OAuth::InvalidRequestResponse < Doorkeeper::OAuth::ErrorResponse
  def description; end
  def initialize(attributes = nil); end
  def reason; end
  def redirectable?; end
  def self.from_request(request, attributes = nil); end
  def status; end
end
class Doorkeeper::OAuth::NonStandard
end
module Doorkeeper::SecretStoring
end
class Doorkeeper::SecretStoring::Base
  def self.allows_restoring_secrets?; end
  def self.restore_secret(_resource, _attribute); end
  def self.secret_matches?(input, stored); end
  def self.store_secret(resource, attribute, plain_secret); end
  def self.transform_secret(_plain_secret); end
  def self.validate_for(model); end
end
class Doorkeeper::SecretStoring::Plain < Doorkeeper::SecretStoring::Base
  def self.allows_restoring_secrets?; end
  def self.restore_secret(resource, attribute); end
  def self.transform_secret(plain_secret); end
end
class Doorkeeper::SecretStoring::Sha256Hash < Doorkeeper::SecretStoring::Base
  def self.allows_restoring_secrets?; end
  def self.transform_secret(plain_secret); end
end
class Doorkeeper::SecretStoring::BCrypt < Doorkeeper::SecretStoring::Base
  def self.allows_restoring_secrets?; end
  def self.bcrypt_present?; end
  def self.secret_matches?(input, stored); end
  def self.transform_secret(plain_secret); end
  def self.validate_for(model); end
end
module Doorkeeper::Models
end
module Doorkeeper::Models::Orderable
  extend ActiveSupport::Concern
end
module Doorkeeper::Models::Orderable::ClassMethods
  def ordered_by(attribute, direction = nil); end
end
module Doorkeeper::Models::Scopes
  def includes_scope?(*required_scopes); end
  def scopes; end
  def scopes=(value); end
  def scopes_string; end
end
module Doorkeeper::Models::Expirable
  def expired?; end
  def expires_at; end
  def expires_in_seconds; end
end
module Doorkeeper::Models::Reusable
  def reusable?; end
end
module Doorkeeper::Models::Revocable
  def old_refresh_token; end
  def refresh_token_revoked_on_use?; end
  def revoke(clock = nil); end
  def revoke_previous_refresh_token!; end
  def revoked?; end
end
module Doorkeeper::Models::Accessible
  def accessible?; end
end
module Doorkeeper::Models::SecretStorable
  def fallback_secret_strategy(*args, &block); end
  def secret_strategy(*args, &block); end
  extend ActiveSupport::Concern
end
module Doorkeeper::Models::SecretStorable::ClassMethods
  def fallback_secret_strategy; end
  def find_by_fallback_token(attr, plain_secret); end
  def find_by_plaintext_token(attr, token); end
  def secret_matches?(input, secret); end
  def secret_strategy; end
  def upgrade_fallback_value(instance, attr, plain_secret); end
end
module Doorkeeper::AccessGrantMixin
  def pkce_supported?; end
  def uses_pkce?; end
  extend ActiveSupport::Concern
  include Doorkeeper::Models::Accessible
  include Doorkeeper::Models::Expirable
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::Revocable
  include Doorkeeper::Models::Scopes
  include Doorkeeper::Models::SecretStorable
  include Doorkeeper::OAuth::Helpers
end
module Doorkeeper::AccessGrantMixin::ClassMethods
  def by_token(token); end
  def fallback_secret_strategy; end
  def generate_code_challenge(code_verifier); end
  def pkce_supported?; end
  def revoke_all_for(application_id, resource_owner, clock = nil); end
  def secret_strategy; end
end
module Doorkeeper::AccessTokenMixin
  def acceptable?(scopes); end
  def as_json(_options = nil); end
  def generate_refresh_token; end
  def generate_token; end
  def plaintext_refresh_token; end
  def plaintext_token; end
  def same_credential?(access_token); end
  def token_generator; end
  def token_type; end
  def use_refresh_token?; end
  extend ActiveSupport::Concern
  include Doorkeeper::Models::Accessible
  include Doorkeeper::Models::Expirable
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::Reusable
  include Doorkeeper::Models::Revocable
  include Doorkeeper::Models::Scopes
  include Doorkeeper::Models::SecretStorable
  include Doorkeeper::OAuth::Helpers
end
module Doorkeeper::AccessTokenMixin::ClassMethods
  def authorized_tokens_for(application_id, resource_owner_id); end
  def by_refresh_token(refresh_token); end
  def by_token(token); end
  def fallback_secret_strategy; end
  def find_access_token_in_batches(relation, *args, &block); end
  def find_matching_token(relation, application, scopes); end
  def find_or_create_for(application, resource_owner_id, scopes, expires_in, use_refresh_token); end
  def last_authorized_token_for(application_id, resource_owner_id); end
  def matching_token_for(application, resource_owner_or_id, scopes); end
  def revoke_all_for(application_id, resource_owner, clock = nil); end
  def scopes_match?(token_scopes, param_scopes, app_scopes); end
  def secret_strategy; end
end
module Doorkeeper::ApplicationMixin
  def redirect_uri=(uris); end
  def secret_matches?(input); end
  extend ActiveSupport::Concern
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::Scopes
  include Doorkeeper::Models::SecretStorable
  include Doorkeeper::OAuth::Helpers
end
module Doorkeeper::ApplicationMixin::ClassMethods
  def by_uid(uid); end
  def by_uid_and_secret(uid, secret); end
  def fallback_secret_strategy; end
  def secret_strategy; end
end
module Doorkeeper::Helpers
end
module Doorkeeper::Helpers::Controller
  def authenticate_admin!; end
  def authenticate_resource_owner!; end
  def config_methods; end
  def current_resource_owner; end
  def doorkeeper_token; end
  def enforce_content_type; end
  def get_error_response_from_exception(exception); end
  def handle_token_exception(exception); end
  def resource_owner_from_credentials; end
  def server; end
  def skip_authorization?; end
  def x_www_form_urlencoded?; end
end
module Doorkeeper::Rails
end
class Doorkeeper::Rails::Routes
  def application_routes(mapping); end
  def authorization_routes(mapping); end
  def authorized_applications_routes(mapping); end
  def generate_routes!(options); end
  def initialize(routes, &block); end
  def introspect_routes(mapping); end
  def map_route(name, method); end
  def mapping; end
  def revoke_routes(mapping); end
  def routes; end
  def self.install!; end
  def self.mapping; end
  def token_info_routes(mapping); end
  def token_routes(mapping); end
end
class Doorkeeper::Rails::Routes::Mapping
  def [](routes); end
  def as; end
  def as=(arg0); end
  def controllers; end
  def controllers=(arg0); end
  def initialize; end
  def skipped?(controller); end
  def skips; end
  def skips=(arg0); end
end
class Doorkeeper::Rails::Routes::Mapper
  def as(alias_names = nil); end
  def controllers(controller_names = nil); end
  def initialize; end
  def map(&block); end
  def skip_controllers(*controller_names); end
end
module Doorkeeper::Rails::Routes::Helper
  def use_doorkeeper(options = nil, &block); end
end
module Doorkeeper::Rails::Helpers
  def doorkeeper_authorize!(*scopes); end
  def doorkeeper_error; end
  def doorkeeper_forbidden_render_options(**arg0); end
  def doorkeeper_invalid_token_response?; end
  def doorkeeper_render_error; end
  def doorkeeper_render_error_with(error); end
  def doorkeeper_render_options(error); end
  def doorkeeper_status_for_error(error, respond_not_found_when_forbidden); end
  def doorkeeper_token; end
  def doorkeeper_unauthorized_render_options(**arg0); end
  def valid_doorkeeper_token?; end
end
module Doorkeeper::Rake
  def self.load_tasks; end
end
class Doorkeeper::StaleRecordsCleaner
  def self.configured_orm; end
  def self.for(base_scope); end
  def self.new(base_scope); end
end
module Doorkeeper::Orm
end
module Doorkeeper::Orm::ActiveRecord
  def self.initialize_application_owner!; end
  def self.initialize_models!; end
  def self.lazy_load(&block); end
  def self.models; end
end
module Doorkeeper::DashboardHelper
  def doorkeeper_errors_for(object, method); end
  def doorkeeper_submit_path(application); end
end
class Doorkeeper::ApplicationController < ApplicationController
  def _layout(lookup_context, formats); end
  def self.__callbacks; end
  def self._helpers; end
  def self._routes; end
  def self._wrapper_options; end
  def self.helpers_path; end
  def self.middleware_stack; end
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_36
  include Doorkeeper::Helpers::Controller
end
module Anonymous_Module_36
  def _generate_paths_by_default; end
  def _routes; end
  def self._routes; end
  def self.full_url_for(options); end
  def self.optimize_routes_generation?; end
  def self.polymorphic_path(record_or_hash_or_array, options = nil); end
  def self.polymorphic_url(record_or_hash_or_array, options = nil); end
  def self.route_for(name, *args); end
  def self.url_for(options); end
  def self.url_options; end
  extend ActiveSupport::Concern
  extend Anonymous_Module_27
  extend Anonymous_Module_28
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_27
  include Anonymous_Module_28
end
class Doorkeeper::ApplicationsController < Doorkeeper::ApplicationController
  def _layout(lookup_context, formats); end
  def application_params; end
  def application_secret; end
  def create; end
  def destroy; end
  def edit; end
  def i18n_scope(action); end
  def index; end
  def new; end
  def self.__callbacks; end
  def self._flash_types; end
  def self._helper_methods; end
  def self._helpers; end
  def self._layout; end
  def self._layout_conditions; end
  def self._routes; end
  def self._wrapper_options; end
  def self.helpers_path; end
  def self.middleware_stack; end
  def set_application; end
  def show; end
  def update; end
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_37
end
module Anonymous_Module_37
  def _generate_paths_by_default; end
  def _routes; end
  def self._routes; end
  def self.full_url_for(options); end
  def self.optimize_routes_generation?; end
  def self.polymorphic_path(record_or_hash_or_array, options = nil); end
  def self.polymorphic_url(record_or_hash_or_array, options = nil); end
  def self.route_for(name, *args); end
  def self.url_for(options); end
  def self.url_options; end
  extend ActiveSupport::Concern
  extend Anonymous_Module_27
  extend Anonymous_Module_28
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_27
  include Anonymous_Module_28
end
class Doorkeeper::AuthorizationsController < Doorkeeper::ApplicationController
  def _layout(lookup_context, formats); end
  def after_successful_authorization; end
  def authorization; end
  def authorize_response; end
  def before_successful_authorization; end
  def create; end
  def destroy; end
  def matching_token?; end
  def new; end
  def pre_auth; end
  def pre_auth_param_fields; end
  def pre_auth_params; end
  def redirect_or_render(auth); end
  def render_error; end
  def render_success; end
  def self.__callbacks; end
  def self._helpers; end
  def self._routes; end
  def self._wrapper_options; end
  def self.helpers_path; end
  def self.middleware_stack; end
  def strategy; end
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_38
end
module Anonymous_Module_38
  def _generate_paths_by_default; end
  def _routes; end
  def self._routes; end
  def self.full_url_for(options); end
  def self.optimize_routes_generation?; end
  def self.polymorphic_path(record_or_hash_or_array, options = nil); end
  def self.polymorphic_url(record_or_hash_or_array, options = nil); end
  def self.route_for(name, *args); end
  def self.url_for(options); end
  def self.url_options; end
  extend ActiveSupport::Concern
  extend Anonymous_Module_27
  extend Anonymous_Module_28
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_27
  include Anonymous_Module_28
end
class Doorkeeper::AuthorizedApplicationsController < Doorkeeper::ApplicationController
  def _layout(lookup_context, formats); end
  def destroy; end
  def index; end
  def self.__callbacks; end
  def self._helpers; end
  def self._routes; end
  def self._wrapper_options; end
  def self.helpers_path; end
  def self.middleware_stack; end
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_39
end
module Anonymous_Module_39
  def _generate_paths_by_default; end
  def _routes; end
  def self._routes; end
  def self.full_url_for(options); end
  def self.optimize_routes_generation?; end
  def self.polymorphic_path(record_or_hash_or_array, options = nil); end
  def self.polymorphic_url(record_or_hash_or_array, options = nil); end
  def self.route_for(name, *args); end
  def self.url_for(options); end
  def self.url_options; end
  extend ActiveSupport::Concern
  extend Anonymous_Module_27
  extend Anonymous_Module_28
  include ActionDispatch::Routing::UrlFor
  include Anonymous_Module_27
  include Anonymous_Module_28
end
class Doorkeeper::Orm::ActiveRecord::StaleRecordsCleaner
  def clean_expired(ttl); end
  def clean_revoked; end
  def initialize(base_scope); end
end
class Doorkeeper::RedirectUriValidator < ActiveModel::EachValidator
  def forbidden_uri?(uri); end
  def invalid_ssl_uri?(uri); end
  def oob_redirect_uri?(uri); end
  def relative_uri?(uri); end
  def unspecified_scheme?(uri); end
  def validate_each(record, attribute, value); end
end
module Doorkeeper::AccessGrant::GeneratedAttributeMethods
end
class Doorkeeper::AccessGrant < ActiveRecord::Base
  def autosave_associated_records_for_application(*args); end
  def generate_token; end
  def plaintext_token; end
  def self.__callbacks; end
  def self._reflections; end
  def self._validators; end
  def self.attribute_type_decorations; end
  def self.defined_enums; end
  def self.page(num = nil); end
  extend Doorkeeper::AccessGrantMixin::ClassMethods
  extend Doorkeeper::Models::Orderable::ClassMethods
  extend Doorkeeper::Models::SecretStorable::ClassMethods
  extend Kaminari::ConfigurationMethods::ClassMethods
  include Doorkeeper::AccessGrant::GeneratedAssociationMethods
  include Doorkeeper::AccessGrant::GeneratedAttributeMethods
  include Doorkeeper::AccessGrantMixin
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::SecretStorable
  include Kaminari::ActiveRecordModelExtension
  include Kaminari::ConfigurationMethods
end
module Doorkeeper::AccessGrant::GeneratedAssociationMethods
  def application; end
  def application=(value); end
  def build_application(*args, &block); end
  def create_application!(*args, &block); end
  def create_application(*args, &block); end
  def reload_application; end
end
class Doorkeeper::AccessGrant::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessGrant::GeneratedRelationMethods
end
module Doorkeeper::AccessGrant::GeneratedRelationMethods
end
class Doorkeeper::AccessGrant::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessGrant::GeneratedRelationMethods
end
class Doorkeeper::AccessGrant::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessGrant::GeneratedRelationMethods
end
module Doorkeeper::AccessToken::GeneratedAttributeMethods
end
class Doorkeeper::AccessToken < ActiveRecord::Base
  def autosave_associated_records_for_application(*args); end
  def self.__callbacks; end
  def self._reflections; end
  def self._validators; end
  def self.active_for(resource_owner); end
  def self.attribute_type_decorations; end
  def self.defined_enums; end
  def self.page(num = nil); end
  def self.refresh_token_revoked_on_use?; end
  def use_refresh_token=(arg0); end
  extend Doorkeeper::AccessTokenMixin::ClassMethods
  extend Doorkeeper::Models::Orderable::ClassMethods
  extend Doorkeeper::Models::SecretStorable::ClassMethods
  extend Kaminari::ConfigurationMethods::ClassMethods
  include Doorkeeper::AccessToken::GeneratedAssociationMethods
  include Doorkeeper::AccessToken::GeneratedAttributeMethods
  include Doorkeeper::AccessTokenMixin
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::SecretStorable
  include Kaminari::ActiveRecordModelExtension
  include Kaminari::ConfigurationMethods
end
module Doorkeeper::AccessToken::GeneratedAssociationMethods
  def application; end
  def application=(value); end
  def build_application(*args, &block); end
  def create_application!(*args, &block); end
  def create_application(*args, &block); end
  def reload_application; end
end
class Doorkeeper::AccessToken::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessToken::GeneratedRelationMethods
end
module Doorkeeper::AccessToken::GeneratedRelationMethods
end
class Doorkeeper::AccessToken::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessToken::GeneratedRelationMethods
end
class Doorkeeper::AccessToken::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::AccessToken::GeneratedRelationMethods
end
module Doorkeeper::Application::GeneratedAttributeMethods
end
class Doorkeeper::Application < ActiveRecord::Base
  def after_add_for_access_grants; end
  def after_add_for_access_grants=(val); end
  def after_add_for_access_grants?; end
  def after_add_for_access_tokens; end
  def after_add_for_access_tokens=(val); end
  def after_add_for_access_tokens?; end
  def after_add_for_authorized_applications; end
  def after_add_for_authorized_applications=(val); end
  def after_add_for_authorized_applications?; end
  def after_add_for_authorized_tokens; end
  def after_add_for_authorized_tokens=(val); end
  def after_add_for_authorized_tokens?; end
  def after_remove_for_access_grants; end
  def after_remove_for_access_grants=(val); end
  def after_remove_for_access_grants?; end
  def after_remove_for_access_tokens; end
  def after_remove_for_access_tokens=(val); end
  def after_remove_for_access_tokens?; end
  def after_remove_for_authorized_applications; end
  def after_remove_for_authorized_applications=(val); end
  def after_remove_for_authorized_applications?; end
  def after_remove_for_authorized_tokens; end
  def after_remove_for_authorized_tokens=(val); end
  def after_remove_for_authorized_tokens?; end
  def autosave_associated_records_for_access_grants(*args); end
  def autosave_associated_records_for_access_tokens(*args); end
  def autosave_associated_records_for_authorized_applications(*args); end
  def autosave_associated_records_for_authorized_tokens(*args); end
  def before_add_for_access_grants; end
  def before_add_for_access_grants=(val); end
  def before_add_for_access_grants?; end
  def before_add_for_access_tokens; end
  def before_add_for_access_tokens=(val); end
  def before_add_for_access_tokens?; end
  def before_add_for_authorized_applications; end
  def before_add_for_authorized_applications=(val); end
  def before_add_for_authorized_applications?; end
  def before_add_for_authorized_tokens; end
  def before_add_for_authorized_tokens=(val); end
  def before_add_for_authorized_tokens?; end
  def before_remove_for_access_grants; end
  def before_remove_for_access_grants=(val); end
  def before_remove_for_access_grants?; end
  def before_remove_for_access_tokens; end
  def before_remove_for_access_tokens=(val); end
  def before_remove_for_access_tokens?; end
  def before_remove_for_authorized_applications; end
  def before_remove_for_authorized_applications=(val); end
  def before_remove_for_authorized_applications?; end
  def before_remove_for_authorized_tokens; end
  def before_remove_for_authorized_tokens=(val); end
  def before_remove_for_authorized_tokens?; end
  def enforce_scopes?; end
  def generate_secret; end
  def generate_uid; end
  def plaintext_secret; end
  def renew_secret; end
  def scopes_match_configured; end
  def self.__callbacks; end
  def self._reflections; end
  def self._validators; end
  def self.after_add_for_access_grants; end
  def self.after_add_for_access_grants=(val); end
  def self.after_add_for_access_grants?; end
  def self.after_add_for_access_tokens; end
  def self.after_add_for_access_tokens=(val); end
  def self.after_add_for_access_tokens?; end
  def self.after_add_for_authorized_applications; end
  def self.after_add_for_authorized_applications=(val); end
  def self.after_add_for_authorized_applications?; end
  def self.after_add_for_authorized_tokens; end
  def self.after_add_for_authorized_tokens=(val); end
  def self.after_add_for_authorized_tokens?; end
  def self.after_remove_for_access_grants; end
  def self.after_remove_for_access_grants=(val); end
  def self.after_remove_for_access_grants?; end
  def self.after_remove_for_access_tokens; end
  def self.after_remove_for_access_tokens=(val); end
  def self.after_remove_for_access_tokens?; end
  def self.after_remove_for_authorized_applications; end
  def self.after_remove_for_authorized_applications=(val); end
  def self.after_remove_for_authorized_applications?; end
  def self.after_remove_for_authorized_tokens; end
  def self.after_remove_for_authorized_tokens=(val); end
  def self.after_remove_for_authorized_tokens?; end
  def self.attribute_type_decorations; end
  def self.authorized_for(resource_owner); end
  def self.before_add_for_access_grants; end
  def self.before_add_for_access_grants=(val); end
  def self.before_add_for_access_grants?; end
  def self.before_add_for_access_tokens; end
  def self.before_add_for_access_tokens=(val); end
  def self.before_add_for_access_tokens?; end
  def self.before_add_for_authorized_applications; end
  def self.before_add_for_authorized_applications=(val); end
  def self.before_add_for_authorized_applications?; end
  def self.before_add_for_authorized_tokens; end
  def self.before_add_for_authorized_tokens=(val); end
  def self.before_add_for_authorized_tokens?; end
  def self.before_remove_for_access_grants; end
  def self.before_remove_for_access_grants=(val); end
  def self.before_remove_for_access_grants?; end
  def self.before_remove_for_access_tokens; end
  def self.before_remove_for_access_tokens=(val); end
  def self.before_remove_for_access_tokens?; end
  def self.before_remove_for_authorized_applications; end
  def self.before_remove_for_authorized_applications=(val); end
  def self.before_remove_for_authorized_applications?; end
  def self.before_remove_for_authorized_tokens; end
  def self.before_remove_for_authorized_tokens=(val); end
  def self.before_remove_for_authorized_tokens?; end
  def self.defined_enums; end
  def self.page(num = nil); end
  def self.revoke_tokens_and_grants_for(id, resource_owner); end
  def to_json(options = nil); end
  def validate_associated_records_for_access_grants(*args); end
  def validate_associated_records_for_access_tokens(*args); end
  def validate_associated_records_for_authorized_applications(*args); end
  def validate_associated_records_for_authorized_tokens(*args); end
  extend Doorkeeper::ApplicationMixin::ClassMethods
  extend Doorkeeper::Models::Orderable::ClassMethods
  extend Doorkeeper::Models::SecretStorable::ClassMethods
  extend Kaminari::ConfigurationMethods::ClassMethods
  include Doorkeeper::Application::GeneratedAssociationMethods
  include Doorkeeper::Application::GeneratedAttributeMethods
  include Doorkeeper::ApplicationMixin
  include Doorkeeper::Models::Orderable
  include Doorkeeper::Models::SecretStorable
  include Kaminari::ActiveRecordModelExtension
  include Kaminari::ConfigurationMethods
end
module Doorkeeper::Application::GeneratedAssociationMethods
  def access_grant_ids; end
  def access_grant_ids=(ids); end
  def access_grants; end
  def access_grants=(value); end
  def access_token_ids; end
  def access_token_ids=(ids); end
  def access_tokens; end
  def access_tokens=(value); end
  def authorized_application_ids; end
  def authorized_application_ids=(ids); end
  def authorized_applications; end
  def authorized_applications=(value); end
  def authorized_token_ids; end
  def authorized_token_ids=(ids); end
  def authorized_tokens; end
  def authorized_tokens=(value); end
end
class Doorkeeper::Application::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::Application::GeneratedRelationMethods
end
module Doorkeeper::Application::GeneratedRelationMethods
end
class Doorkeeper::Application::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::Application::GeneratedRelationMethods
end
class Doorkeeper::Application::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include Doorkeeper::Application::GeneratedRelationMethods
end
module Doorkeeper::Models::Ownership
  def validate_owner?; end
  extend ActiveSupport::Concern
end
