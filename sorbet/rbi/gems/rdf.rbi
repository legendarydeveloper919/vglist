# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rdf/all/rdf.rbi
#
# rdf-3.1.1

module RDF
  def self.Graph(**options, &block); end
  def self.List(*args); end
  def self.Literal(literal, **options); end
  def self.Node(*args); end
  def self.Resource(*args); end
  def self.Statement(*args, **options); end
  def self.StrictVocabulary(prefix); end
  def self.URI(*args); end
  def self.Vocabulary(uri); end
  def self.[](property); end
  def self.const_missing(constant); end
  def self.enum_for(method = nil, *args); end
  def self.method_missing(property, *args, &block); end
  def self.respond_to?(method, include_all = nil); end
  def self.to_enum(method = nil, *args); end
end
module RDF::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
class RDF::Format
  def self.accept_type; end
  def self.accept_types; end
  def self.cli_commands; end
  def self.content_encoding(encoding = nil); end
  def self.content_type(type = nil, options = nil); end
  def self.content_types; end
  def self.detect(sample); end
  def self.each(file_name: nil, file_extension: nil, content_type: nil, has_reader: nil, has_writer: nil, sample: nil, all_if_none: nil, **options, &block); end
  def self.file_extension; end
  def self.file_extensions; end
  def self.for(*arg, &block); end
  def self.inherited(child); end
  def self.name; end
  def self.new(*arg0); end
  def self.reader(klass = nil, &block); end
  def self.reader_class(klass = nil, &block); end
  def self.reader_symbols; end
  def self.reader_types; end
  def self.require(library); end
  def self.symbols; end
  def self.to_sym; end
  def self.writer(klass = nil, &block); end
  def self.writer_class(klass = nil, &block); end
  def self.writer_symbols; end
  def self.writer_types; end
  extend Enumerable
end
class RDF::FormatError < IOError
end
module RDF::NTriples
  def self.escape(string); end
  def self.serialize(value); end
  def self.unescape(string); end
  def self.unserialize(data); end
end
class RDF::NTriples::Format < RDF::Format
  def self.detect(sample); end
  def self.name; end
end
module RDF::Value
  def anonymous?; end
  def canonicalize!; end
  def canonicalize; end
  def constant?; end
  def graph?; end
  def inspect!; end
  def inspect; end
  def invalid?; end
  def iri?; end
  def list?; end
  def literal?; end
  def node?; end
  def resource?; end
  def start_with?(string); end
  def starts_with?(string); end
  def statement?; end
  def term?; end
  def to_nquads; end
  def to_ntriples; end
  def to_rdf; end
  def to_term; end
  def type_error(message); end
  def uri?; end
  def valid?; end
  def validate!; end
  def validate; end
  def variable?; end
end
module RDF::Util
end
module RDF::Util::Aliasing
end
module RDF::Util::Aliasing::LateBound
  def alias_method(new_name, old_name); end
end
module RDF::Countable
  def count; end
  def empty?; end
  def enum_for(method = nil, *args); end
  def size(*args, &block); end
  def to_enum(*args, &block); end
  extend RDF::Util::Aliasing::LateBound
end
module RDF::Durable
  def durable?; end
  def ephemeral?(*args, &block); end
  def nondurable?; end
  def nonpersistent?(*args, &block); end
  def persistent?(*args, &block); end
  def transient?(*args, &block); end
  def volatile?(*args, &block); end
  extend RDF::Util::Aliasing::LateBound
end
module RDF::Enumerable
  def dump(*args, **options); end
  def each_graph; end
  def each_object; end
  def each_predicate; end
  def each_quad; end
  def each_statement(&block); end
  def each_subject; end
  def each_term; end
  def each_triple; end
  def enum_for(method = nil, *args); end
  def enum_graph; end
  def enum_graphs(*args, &block); end
  def enum_object; end
  def enum_objects(*args, &block); end
  def enum_predicate; end
  def enum_predicates(*args, &block); end
  def enum_quad; end
  def enum_quads(*args, &block); end
  def enum_statement; end
  def enum_statements(*args, &block); end
  def enum_subject; end
  def enum_subjects(*args, &block); end
  def enum_term; end
  def enum_terms(*args, &block); end
  def enum_triple; end
  def enum_triples(*args, &block); end
  def graph_names(unique: nil); end
  def has_graph?(graph_name); end
  def has_object?(value); end
  def has_predicate?(value); end
  def has_quad?(quad); end
  def has_statement?(statement); end
  def has_subject?(value); end
  def has_term?(value); end
  def has_triple?(triple); end
  def include?(*args, &block); end
  def invalid?; end
  def method_missing(meth, *args); end
  def objects(unique: nil); end
  def predicates(unique: nil); end
  def project_graph(graph_name); end
  def quads(**options); end
  def respond_to_missing?(name, include_private = nil); end
  def statements(**options); end
  def subjects(unique: nil); end
  def supports?(feature); end
  def terms(unique: nil); end
  def to_a; end
  def to_enum(*args, &block); end
  def to_h; end
  def to_set; end
  def triples(**options); end
  def valid?; end
  def validate!; end
  def validate(*args, &block); end
  extend RDF::Util::Aliasing::LateBound
  include Enumerable
  include RDF::Countable
end
module RDF::Indexable
  def index!; end
  def indexed?; end
end
module RDF::Readable
  def readable?; end
  extend RDF::Util::Aliasing::LateBound
end
module RDF::Util::Coercions
  def coerce_statements(statements, query: nil, constant: nil, &block); end
end
module RDF::Writable
  def <<(data); end
  def insert!(*args, &block); end
  def insert(*statements); end
  def insert_graph(graph); end
  def insert_reader(reader); end
  def insert_statement(statement); end
  def insert_statements(statements); end
  def writable?; end
  extend RDF::Util::Aliasing::LateBound
  include RDF::Util::Coercions
end
module RDF::Mutable
  def <<(data); end
  def apply_changeset(changeset); end
  def clear!(*args, &block); end
  def clear; end
  def delete!(*args, &block); end
  def delete(*statements); end
  def delete_insert!(*args, &block); end
  def delete_insert(deletes, inserts); end
  def delete_statement(statement); end
  def delete_statements(statements); end
  def immutable?; end
  def insert(*statements); end
  def load!(*args, &block); end
  def load(url, graph_name: nil, **options); end
  def method_missing(meth, *args); end
  def mutable?; end
  def respond_to_missing?(name, include_private = nil); end
  def snapshot; end
  def update!(*args, &block); end
  def update(*statements); end
  extend RDF::Util::Aliasing::LateBound
  include RDF::Readable
  include RDF::Util::Coercions
  include RDF::Writable
end
module RDF::Queryable
  def enum_for(method = nil, *args); end
  def first(pattern = nil); end
  def first_literal(pattern = nil); end
  def first_object(pattern = nil); end
  def first_predicate(pattern = nil); end
  def first_subject(pattern = nil); end
  def first_value(pattern = nil); end
  def query(pattern, options = nil, &block); end
  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
  def to_enum(method = nil, *args); end
  include Enumerable
end
module RDF::TypeCheck
  def type_error(message); end
end
module RDF::Transactable
  def begin_transaction(mutable: nil, graph_name: nil); end
  def commit_transaction(tx); end
  def rollback_transaction(tx); end
  def transact(mutable: nil, &block); end
  def transaction(mutable: nil, &block); end
end
class RDF::Graph
  def ==(other); end
  def anonymous?; end
  def begin_transaction(mutable: nil, graph_name: nil); end
  def clear_statements; end
  def count; end
  def data; end
  def data=(arg0); end
  def delete_statement(statement); end
  def durable?; end
  def each(&block); end
  def each_graph; end
  def graph?; end
  def graph_name; end
  def graph_name=(arg0); end
  def graph_names(unique: nil); end
  def graphs; end
  def has_statement?(statement); end
  def initialize(graph_name: nil, data: nil, **options, &block); end
  def insert_statement(statement); end
  def insert_statements(statements); end
  def load!(*args); end
  def name; end
  def name=(arg0); end
  def named?; end
  def options; end
  def project_graph(graph_name, &block); end
  def query_pattern(pattern, **options, &block); end
  def self.load(url, graph_name: nil, **options, &block); end
  def to_s; end
  def to_uri; end
  def unnamed?; end
  include RDF::Countable
  include RDF::Durable
  include RDF::Enumerable
  include RDF::Mutable
  include RDF::Queryable
  include RDF::Transactable
  include RDF::Value
end
module RDF::Term
  def <=>(other); end
  def ==(other); end
  def compatible?(other); end
  def eql?(other); end
  def escape(string); end
  def term?; end
  def to_base; end
  def to_term; end
  include Comparable
  include RDF::Value
end
module RDF::Resource
  def resource?; end
  def self.new(*args, &block); end
  include RDF::Term
end
class RDF::URI
  def +(other); end
  def /(fragment); end
  def ==(other); end
  def ===(other); end
  def =~(pattern); end
  def _dump(level); end
  def absolute?; end
  def authority; end
  def authority=(value); end
  def canonicalize!; end
  def canonicalize; end
  def dup; end
  def end_with?(string); end
  def ends_with?(string); end
  def eql?(other); end
  def format_authority; end
  def format_userinfo(append = nil); end
  def fragment; end
  def fragment=(value); end
  def freeze; end
  def has_parent?; end
  def hash; end
  def hier?; end
  def host; end
  def host=(value); end
  def initialize(*args, validate: nil, canonicalize: nil, **options); end
  def inspect; end
  def join(*uris); end
  def length; end
  def normalize!; end
  def normalize; end
  def normalize_segment(value, expr, downcase = nil); end
  def normalized_authority; end
  def normalized_fragment; end
  def normalized_host; end
  def normalized_password; end
  def normalized_path; end
  def normalized_port; end
  def normalized_query; end
  def normalized_scheme; end
  def normalized_user; end
  def normalized_userinfo; end
  def object; end
  def parent; end
  def parse(value); end
  def password; end
  def password=(value); end
  def path; end
  def path=(value); end
  def pname; end
  def port; end
  def port=(value); end
  def qname; end
  def query; end
  def query=(value); end
  def query_values(return_type = nil); end
  def query_values=(value); end
  def relative?; end
  def relativize(base_uri); end
  def request_uri; end
  def root; end
  def root?; end
  def scheme; end
  def scheme=(value); end
  def self._load(data); end
  def self.cache; end
  def self.decode(str); end
  def self.encode(str, expr); end
  def self.intern(str, *args, **options); end
  def self.normalize_path(path); end
  def self.parse(str); end
  def size; end
  def to_h; end
  def to_s; end
  def to_str; end
  def to_uri; end
  def uri?; end
  def url?; end
  def urn?; end
  def user; end
  def user=(value); end
  def userinfo; end
  def userinfo=(value); end
  def valid?; end
  def validate!; end
  def value; end
  include RDF::Resource
end
class RDF::Literal
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = nil); end
  def initialize(value, language: nil, datatype: nil, lexical: nil, validate: nil, canonicalize: nil, **options); end
  def inspect; end
  def language; end
  def language=(arg0); end
  def language?; end
  def literal?; end
  def method_missing(name, *args); end
  def object; end
  def plain?; end
  def respond_to_missing?(name, include_private = nil); end
  def self.datatype_map; end
  def self.datatyped_class(uri); end
  def self.inherited(child); end
  def self.new(value, language: nil, datatype: nil, lexical: nil, validate: nil, canonicalize: nil, **options); end
  def simple?; end
  def squish!; end
  def squish(*other_string); end
  def to_s; end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end
  include RDF::Term
end
class RDF::Literal::Numeric < RDF::Literal
  def *(other); end
  def +(other); end
  def +@; end
  def -(other); end
  def -@; end
  def /(other); end
  def <=>(other); end
  def ==(other); end
  def abs; end
  def ceil; end
  def floor; end
  def ord; end
  def round; end
  def to_d; end
  def to_f; end
  def to_i; end
  def to_int; end
  def to_r; end
end
class RDF::Literal::Boolean < RDF::Literal
  def <=>(other); end
  def ==(other); end
  def canonicalize!; end
  def false?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def inspect; end
  def to_i; end
  def to_s; end
  def true?; end
end
class RDF::Literal::Decimal < RDF::Literal::Numeric
  def abs; end
  def canonicalize!; end
  def ceil; end
  def floor; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def nonzero?; end
  def round; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Integer < RDF::Literal::Decimal
  def abs; end
  def canonicalize!; end
  def even?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def next; end
  def nonzero?; end
  def odd?; end
  def pred; end
  def round; end
  def succ; end
  def to_bn; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Double < RDF::Literal::Numeric
  def <=>(other); end
  def ==(other); end
  def abs; end
  def canonicalize!; end
  def ceil; end
  def finite?; end
  def floor; end
  def infinite?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def nan?; end
  def nonzero?; end
  def round; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Date < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::DateTime < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_milliseconds?; end
  def has_ms?; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def timezone; end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::Time < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::Token < RDF::Literal
  def canonicalize!; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def to_sym; end
end
class RDF::Node
  def ==(other); end
  def ===(other); end
  def anonymous?; end
  def dup; end
  def eql?(other); end
  def hash; end
  def id; end
  def id=(arg0); end
  def initialize(id = nil); end
  def labeled?; end
  def make_unique!; end
  def node?; end
  def original; end
  def original=(arg0); end
  def self.cache; end
  def self.intern(id); end
  def self.uuid(format: nil); end
  def to_s; end
  def to_sym; end
  def to_unique_base; end
  def unlabeled?; end
  include RDF::Resource
end
class RDF::Statement
  def ==(other); end
  def ===(other); end
  def [](index); end
  def []=(index, value); end
  def asserted?; end
  def canonicalize!; end
  def canonicalize; end
  def complete?; end
  def eql?(other); end
  def graph_name; end
  def graph_name=(arg0); end
  def has_blank_nodes?; end
  def has_graph?; end
  def has_name?; end
  def has_object?; end
  def has_predicate?; end
  def has_subject?; end
  def hash; end
  def id; end
  def id=(arg0); end
  def incomplete?; end
  def inferred?; end
  def initialize!; end
  def initialize(subject = nil, predicate = nil, object = nil, options = nil); end
  def invalid?; end
  def node?; end
  def object; end
  def object=(arg0); end
  def options; end
  def options=(arg0); end
  def predicate; end
  def predicate=(arg0); end
  def quoted?; end
  def reified(subject: nil, id: nil, graph_name: nil); end
  def self.from(statement, graph_name: nil, **options); end
  def statement?; end
  def subject; end
  def subject=(arg0); end
  def to_a; end
  def to_h(subject_key = nil, predicate_key = nil, object_key = nil, graph_key = nil); end
  def to_quad; end
  def to_s; end
  def to_triple; end
  def valid?; end
  def variable?; end
  include RDF::Value
end
class RDF::Vocabulary
  def [](property); end
  def initialize(uri); end
  def inspect; end
  def method_missing(property, *args, &block); end
  def self.[](property); end
  def self.__imports__; end
  def self.__name__; end
  def self.__ontology__(*args); end
  def self.__prefix__; end
  def self.__properties__; end
  def self.__property__(*args); end
  def self.camelize(str); end
  def self.create(uri); end
  def self.each(&block); end
  def self.each_statement(&block); end
  def self.enum_for(method = nil, *args); end
  def self.expand_pname(pname); end
  def self.find(uri); end
  def self.find_term(uri); end
  def self.from_graph(graph, url: nil, class_name: nil, extra: nil); end
  def self.imported_from; end
  def self.imports; end
  def self.inherited(subclass); end
  def self.inspect; end
  def self.list(*values); end
  def self.method_missing(property, *args, &block); end
  def self.ontology(*args); end
  def self.properties; end
  def self.property(*args); end
  def self.props; end
  def self.strict?; end
  def self.term(*args); end
  def self.to_enum(method = nil, *args); end
  def self.to_iri; end
  def self.to_s; end
  def self.to_uri; end
  def to_iri; end
  def to_s; end
  def to_uri; end
  extend Enumerable
end
module RDF::Vocabulary::Term
  def attribute_value(prop); end
  def attributes; end
  def class?; end
  def datatype?; end
  def domain_includes; end
  def dup; end
  def each_statement; end
  def enum_for(method = nil, *args); end
  def inspect; end
  def method_missing(method, *args, &block); end
  def other?; end
  def properties; end
  def property?; end
  def range_includes; end
  def respond_to?(method, include_all = nil); end
  def restriction?; end
  def self.intern(str, *args, **options); end
  def self.new(*args, vocab: nil, attributes: nil, **options); end
  def to_enum(method = nil, *args); end
  def to_ruby(indent: nil); end
  def valid?; end
  def vocab; end
  include RDF::Resource
end
class RDF::StrictVocabulary < RDF::Vocabulary
  def self.[](name); end
  def self.method_missing(*arg0); end
  def self.strict?; end
end
class RDF::Util::Cache
  def has_capacity?; end
  def initialize(capacity = nil); end
  def self.new(*args); end
  def size; end
end
class RDF::Util::Cache::ObjectSpaceCache < RDF::Util::Cache
  def [](key); end
  def []=(key, value); end
  def delete(key); end
end
class RDF::Util::Cache::WeakRefCache < RDF::Util::Cache
  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def initialize(capacity = nil); end
end
class RDF::RDFV < RDF::StrictVocabulary
  def self.Alt; end
  def self.Bag; end
  def self.CompoundLiteral; end
  def self.Description; end
  def self.HTML; end
  def self.ID; end
  def self.JSON; end
  def self.List; end
  def self.PlainLiteral; end
  def self.Property; end
  def self.Seq; end
  def self.Statement; end
  def self.XMLLiteral; end
  def self.__name__; end
  def self.about; end
  def self.datatype; end
  def self.direction; end
  def self.first; end
  def self.langString; end
  def self.language; end
  def self.li; end
  def self.name; end
  def self.new(*arg0); end
  def self.nil; end
  def self.nodeID; end
  def self.object; end
  def self.parseType; end
  def self.predicate; end
  def self.resource; end
  def self.rest; end
  def self.subject; end
  def self.type; end
  def self.value; end
end
class RDF::Dataset
  def durable?; end
  def each; end
  def initialize(statements: nil, **options, &block); end
  def inspect!; end
  def inspect; end
  def isolation_level; end
  def query_pattern(pattern, **options, &block); end
  def supports?(feature); end
  include RDF::Durable
  include RDF::Enumerable
  include RDF::Queryable
end
class RDF::Transaction
  def changes; end
  def delete_statement(statement); end
  def each(*args, &block); end
  def execute; end
  def graph_name; end
  def has_statement?(statement); end
  def initialize(repository, graph_name: nil, mutable: nil, **options, &block); end
  def insert_statement(statement); end
  def inspect!; end
  def inspect; end
  def isolation_level; end
  def mutable?; end
  def mutated?; end
  def options; end
  def process_statement(statement); end
  def query_execute(*args, &block); end
  def query_pattern(*args, &block); end
  def read_target; end
  def readable?; end
  def repository; end
  def rollback; end
  def self.begin(repository, mutable: nil, **options, &block); end
  def writable?; end
  include RDF::Enumerable
  include RDF::Mutable
  include RDF::Queryable
end
class RDF::Transaction::TransactionError < RuntimeError
end
class RDF::Repository < RDF::Dataset
  def begin_transaction(mutable: nil, graph_name: nil); end
  def delete_insert(deletes, inserts); end
  def initialize(uri: nil, title: nil, **options, &block); end
  def isolation_level; end
  def options; end
  def project_graph(graph_name, &block); end
  def self.load(urls, **options, &block); end
  def snapshot; end
  def supports?(feature); end
  def title; end
  def uri; end
  def url; end
  include RDF::Mutable
  include RDF::Transactable
end
module RDF::Repository::Implementation
  def apply_changeset(changeset); end
  def clear_statements; end
  def count; end
  def data; end
  def data=(hash); end
  def delete_from(data, statement); end
  def delete_statement(statement); end
  def each(&block); end
  def each_graph(&block); end
  def each_statement(&block); end
  def graph_names(options = nil, &block); end
  def has_graph?(graph); end
  def has_statement?(statement); end
  def has_statement_in?(data, statement); end
  def insert_statement(statement); end
  def insert_to(data, statement); end
  def isolation_level; end
  def query_pattern(pattern, **options, &block); end
  def self.extend_object(obj); end
  def snapshot; end
  def supports?(feature); end
end
class RDF::Repository::Implementation::SerializedTransaction < RDF::Transaction
  def delete_statement(statement); end
  def execute; end
  def initialize(*args, **options, &block); end
  def insert_statement(statement); end
  def isolation_level; end
  def mutated?; end
end
class RDF::Query
  def +(other); end
  def <<(pattern); end
  def apply_graph_name(graph_name = nil); end
  def compile_hash_patterns(hash_patterns); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def execute(queryable, bindings: nil, solutions: nil, graph_name: nil, name: nil, **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(arg0); end
  def has_blank_nodes?; end
  def has_variables?; end
  def initialize(*patterns, solutions: nil, graph_name: nil, name: nil, validate: nil, **options, &block); end
  def matched?; end
  def named?; end
  def node?; end
  def optimize!(**options); end
  def optimize(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def self.Solutions(*args); end
  def self.execute(queryable, patterns = nil, options = nil, &block); end
  def solutions; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?; end
  def variable_count; end
  def variables; end
  def variables?; end
  include RDF::Enumerable
end
class RDF::Query::Pattern < RDF::Statement
  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(arg0); end
  def execute(queryable, bindings = nil, &block); end
  def has_variables?; end
  def initialize!; end
  def initialize(subject = nil, predicate = nil, object = nil, options = nil); end
  def optional?; end
  def options; end
  def self.from(pattern, graph_name: nil, **options); end
  def solution(statement); end
  def to_s; end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def variable_count; end
  def variable_terms(name = nil); end
  def variables; end
  def variables?; end
end
class RDF::Query::Variable
  def ==(other); end
  def ===(other); end
  def bind!(value); end
  def bind(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def initialize(name = nil, value = nil, distinguished: nil, existential: nil); end
  def name; end
  def name=(arg0); end
  def named?; end
  def to_h; end
  def to_s; end
  def to_sym; end
  def unbind!; end
  def unbind; end
  def unbound?; end
  def value; end
  def value=(arg0); end
  def variable?; end
  def variables; end
  include RDF::Term
end
class RDF::Enumerable::Enumerator < Enumerator
  def to_a; end
  include RDF::Enumerable
  include RDF::Queryable
end
class RDF::Countable::Enumerator < Enumerator
  include RDF::Countable
end
class RDF::Queryable::Enumerator < Enumerator
  def to_a; end
  include RDF::Enumerable
  include RDF::Queryable
end
class RDF::List
  def &(other); end
  def *(int_or_str); end
  def +(other); end
  def -(other); end
  def <<(value); end
  def <=>(other); end
  def ==(other); end
  def [](*args); end
  def []=(*args); end
  def at(index); end
  def clear; end
  def each; end
  def each_statement(&block); end
  def each_subject; end
  def eighth; end
  def empty?; end
  def eql?(other); end
  def fetch(index, default = nil); end
  def fifth; end
  def first; end
  def first_subject; end
  def fourth; end
  def graph; end
  def index(value); end
  def initialize(subject: nil, graph: nil, values: nil, &block); end
  def inspect; end
  def join(sep = nil); end
  def last; end
  def last_subject; end
  def length; end
  def list?; end
  def ninth; end
  def normalize_value(value); end
  def nth(index); end
  def rest; end
  def rest_subject; end
  def reverse; end
  def second; end
  def self.[](*values); end
  def seventh; end
  def shift; end
  def sixth; end
  def size; end
  def slice(*args); end
  def slice_with_range(range); end
  def slice_with_start_and_length(start, length); end
  def sort(&block); end
  def sort_by(&block); end
  def subject; end
  def tail; end
  def tenth; end
  def third; end
  def to_a; end
  def to_rdf(&block); end
  def to_s; end
  def to_set; end
  def to_term; end
  def uniq; end
  def unshift(value); end
  def valid?; end
  def |(other); end
  include Comparable
  include RDF::Enumerable
  include RDF::Value
end
module RDF::Util::Logger
  def log_debug(*args, level: nil, **options, &block); end
  def log_depth(**options, &block); end
  def log_error(*args, level: nil, **options, &block); end
  def log_fatal(*args, level: nil, **options, &block); end
  def log_info(*args, level: nil, **options, &block); end
  def log_recover(*args, level: nil, **options, &block); end
  def log_recovering?(**options); end
  def log_statistics(**options); end
  def log_warn(*args, level: nil, **options, &block); end
  def logger(**options); end
  def logger_common(*args, level:, **options); end
end
class RDF::Util::Logger::IOWrapper < Delegator
  def <<(*args, &block); end
  def <=>(*args, &block); end
  def __getobj__; end
  def __setobj__(obj); end
  def acts_like?(*args, &block); end
  def advise(*args, &block); end
  def all?(*args, &block); end
  def any?(*args, &block); end
  def as_json(*args, &block); end
  def at_exit(*args, &block); end
  def autoclose=(*args, &block); end
  def autoclose?(*args, &block); end
  def beep(*args, &block); end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def blank?(*args, &block); end
  def bullet_key(*args, &block); end
  def bullet_primary_key_value(*args, &block); end
  def byebug(*args, &block); end
  def bytes(*args, &block); end
  def chain(*args, &block); end
  def chars(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def class_eval(*args, &block); end
  def close(*args, &block); end
  def close_on_exec=(*args, &block); end
  def close_on_exec?(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def codepoints(*args, &block); end
  def collect(*args, &block); end
  def collect_concat(*args, &block); end
  def cooked!(*args, &block); end
  def cooked(*args, &block); end
  def count(*args, &block); end
  def cursor(*args, &block); end
  def cursor=(*args, &block); end
  def cycle(*args, &block); end
  def debugger(*args, &block); end
  def deep_dup(*args, &block); end
  def detect(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def duplicable?(*args, &block); end
  def each(*args, &block); end
  def each_byte(*args, &block); end
  def each_char(*args, &block); end
  def each_codepoint(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_line(*args, &block); end
  def each_slice(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end
  def echo=(*args, &block); end
  def echo?(*args, &block); end
  def entries(*args, &block); end
  def eof(*args, &block); end
  def eof?(*args, &block); end
  def exclude?(*args, &block); end
  def excluding(*args, &block); end
  def exit(*args, &block); end
  def external_encoding(*args, &block); end
  def fcntl(*args, &block); end
  def fdatasync(*args, &block); end
  def fileno(*args, &block); end
  def filter(*args, &block); end
  def find(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def flat_map(*args, &block); end
  def flush(*args, &block); end
  def friendly_id?(*args, &block); end
  def fsync(*args, &block); end
  def getbyte(*args, &block); end
  def getc(*args, &block); end
  def getch(*args, &block); end
  def getpass(*args, &block); end
  def gets(*args, &block); end
  def goto(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end
  def hash(*args, &block); end
  def html_safe?(*args, &block); end
  def iflush(*args, &block); end
  def in?(*args, &block); end
  def include?(*args, &block); end
  def including(*args, &block); end
  def index_by(*args, &block); end
  def index_with(*args, &block); end
  def inject(*args, &block); end
  def instance_values(*args, &block); end
  def instance_variable_names(*args, &block); end
  def internal_encoding(*args, &block); end
  def ioctl(*args, &block); end
  def ioflush(*args, &block); end
  def isatty(*args, &block); end
  def lazy(*args, &block); end
  def lineno(*args, &block); end
  def lineno=(*args, &block); end
  def lines(*args, &block); end
  def load_dependency(*args, &block); end
  def many?(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def noecho(*args, &block); end
  def nonblock(*args, &block); end
  def nonblock=(*args, &block); end
  def nonblock?(*args, &block); end
  def none?(*args, &block); end
  def nread(*args, &block); end
  def oflush(*args, &block); end
  def one?(*args, &block); end
  def partition(*args, &block); end
  def pathconf(*args, &block); end
  def pid(*args, &block); end
  def pluck(*args, &block); end
  def pos(*args, &block); end
  def pos=(*args, &block); end
  def pread(*args, &block); end
  def presence(*args, &block); end
  def presence_in(*args, &block); end
  def present?(*args, &block); end
  def pressed?(*args, &block); end
  def pretty_inspect(*args, &block); end
  def pretty_print(*args, &block); end
  def pretty_print_cycle(*args, &block); end
  def pretty_print_inspect(*args, &block); end
  def pretty_print_instance_variables(*args, &block); end
  def print(*args, &block); end
  def printf(*args, &block); end
  def putc(*args, &block); end
  def puts(*args, &block); end
  def pwrite(*args, &block); end
  def raw!(*args, &block); end
  def raw(*args, &block); end
  def read(*args, &block); end
  def read_nonblock(*args, &block); end
  def readbyte(*args, &block); end
  def readchar(*args, &block); end
  def readline(*args, &block); end
  def readlines(*args, &block); end
  def readpartial(*args, &block); end
  def ready?(*args, &block); end
  def reduce(*args, &block); end
  def reject(*args, &block); end
  def remote_byebug(*args, &block); end
  def reopen(*args, &block); end
  def require_dependency(*args, &block); end
  def require_or_load(*args, &block); end
  def reverse_each(*args, &block); end
  def rewind(*args, &block); end
  def seek(*args, &block); end
  def select(*args, &block); end
  def self.protected_instance_methods(all = nil); end
  def self.public_instance_methods(all = nil); end
  def set_encoding(*args, &block); end
  def should(*args, &block); end
  def should_not(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort(*args, &block); end
  def sort_by(*args, &block); end
  def stat(*args, &block); end
  def sum(*args, &block); end
  def sync(*args, &block); end
  def sync=(*args, &block); end
  def sysread(*args, &block); end
  def sysseek(*args, &block); end
  def syswrite(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def tell(*args, &block); end
  def to_a(*args, &block); end
  def to_h(*args, &block); end
  def to_i(*args, &block); end
  def to_io(*args, &block); end
  def to_json(*args, &block); end
  def to_list(*args, &block); end
  def to_param(*args, &block); end
  def to_query(*args, &block); end
  def to_set(*args, &block); end
  def to_yaml(*args, &block); end
  def try!(*args, &block); end
  def try(*args, &block); end
  def tty?(*args, &block); end
  def unfriendly_id?(*args, &block); end
  def ungetbyte(*args, &block); end
  def ungetc(*args, &block); end
  def uniq(*args, &block); end
  def unloadable(*args, &block); end
  def wait(*args, &block); end
  def wait_readable(*args, &block); end
  def wait_writable(*args, &block); end
  def winsize(*args, &block); end
  def winsize=(*args, &block); end
  def with_options(*args, &block); end
  def without(*args, &block); end
  def write(*args, &block); end
  def write_nonblock(*args, &block); end
  def zip(*args, &block); end
end
module RDF::Util::Logger::LoggerBehavior
  def log_depth(depth: nil, **options); end
  def log_statistics; end
  def method_missing(method, *args); end
  def recovering; end
  def recovering=(arg0); end
  def respond_to_missing?(name, include_private = nil); end
end
class RDF::Reader
  def base_uri; end
  def blank?; end
  def canonicalize?; end
  def close!(*args, &block); end
  def close; end
  def current_line; end
  def each(*args, &block); end
  def each_statement(&block); end
  def each_triple(&block); end
  def encoding; end
  def fail_object; end
  def fail_predicate; end
  def fail_subject; end
  def initialize(input = nil, encoding: nil, validate: nil, canonicalize: nil, intern: nil, prefixes: nil, base_uri: nil, **options, &block); end
  def intern?; end
  def lineno; end
  def match(pattern); end
  def options; end
  def prefix!(*args, &block); end
  def prefix(name, uri = nil); end
  def prefixes; end
  def prefixes=(prefixes); end
  def read_statement; end
  def read_triple; end
  def readline; end
  def rewind!(*args, &block); end
  def rewind; end
  def self.each(&block); end
  def self.for(*arg, &block); end
  def self.format(klass = nil); end
  def self.format_class(klass = nil); end
  def self.inherited(child); end
  def self.open(filename, format: nil, **options, &block); end
  def self.options; end
  def self.to_sym; end
  def strip!; end
  def to_sym; end
  def valid?; end
  def validate?; end
  extend Enumerable
  extend RDF::Util::Aliasing::LateBound
  include RDF::Enumerable
  include RDF::Readable
  include RDF::Util::Logger
end
class RDF::ReaderError < IOError
  def initialize(message, token: nil, lineno: nil); end
  def lineno; end
  def token; end
end
class RDF::Writer
  def base_uri; end
  def canonicalize?; end
  def encoding; end
  def escaped(string); end
  def flush!(*args, &block); end
  def flush; end
  def format_list(value, **options); end
  def format_literal(value, **options); end
  def format_node(value, **options); end
  def format_term(term, **options); end
  def format_uri(value, **options); end
  def initialize(output = nil, **options, &block); end
  def insert_statement(*args, &block); end
  def node_id; end
  def options; end
  def prefix!(*args, &block); end
  def prefix(name, uri = nil); end
  def prefixes; end
  def prefixes=(prefixes); end
  def puts(*args); end
  def quoted(string); end
  def self.accept?(accept_params); end
  def self.buffer(*args, **options, &block); end
  def self.dump(data, io = nil, **options); end
  def self.each(&block); end
  def self.for(*arg, &block); end
  def self.format(klass = nil); end
  def self.format_class(klass = nil); end
  def self.inherited(child); end
  def self.open(filename, format: nil, **options, &block); end
  def self.options; end
  def self.to_sym; end
  def to_sym; end
  def uri_for(term); end
  def validate?; end
  def write_comment(text); end
  def write_epilogue; end
  def write_prologue; end
  def write_statement(statement); end
  def write_triple(subject, predicate, object); end
  def write_triples(*triples); end
  extend Enumerable
  extend RDF::Util::Aliasing::LateBound
  include RDF::Util::Logger
  include RDF::Writable
end
class RDF::WriterError < IOError
end
class RDF::NTriples::Reader < RDF::Reader
  def read_comment; end
  def read_eos; end
  def read_literal; end
  def read_node; end
  def read_triple; end
  def read_uriref(intern: nil, **options); end
  def read_value; end
  def self.parse_literal(input, **options); end
  def self.parse_node(input, **options); end
  def self.parse_object(input, **options); end
  def self.parse_predicate(input, **options); end
  def self.parse_subject(input, **options); end
  def self.parse_uri(input, intern: nil, **options); end
  def self.unescape(string); end
  def self.unserialize(input, **options); end
  include RDF::Util::Logger
end
class RDF::NTriples::Writer < RDF::Writer
  def escaped(string); end
  def format_literal(literal, **options); end
  def format_node(node, unique_bnodes: nil, **options); end
  def format_statement(statement, **options); end
  def format_triple(subject, predicate, object, **options); end
  def format_uri(uri, **options); end
  def initialize(output = nil, validate: nil, **options, &block); end
  def self.escape(string, encoding = nil); end
  def self.escape_ascii(u, encoding); end
  def self.escape_unicode(u, encoding); end
  def self.escape_utf16(u); end
  def self.escape_utf32(u); end
  def self.serialize(value); end
  def write_comment(text); end
  def write_triple(subject, predicate, object); end
  include RDF::Util::Logger
end
module RDF::NQuads
  def self.serialize(value); end
  def self.unserialize(data); end
  include RDF::NTriples
end
class RDF::NQuads::Format < RDF::Format
  def self.detect(sample); end
  def self.name; end
end
class RDF::NQuads::Reader < RDF::NTriples::Reader
  def read_triple; end
end
class RDF::NQuads::Writer < RDF::NTriples::Writer
  def format_quad(subject, predicate, object, graph_name, **options); end
  def format_statement(statement, **options); end
  def write_quad(subject, predicate, object, graph_name); end
end
class RDF::Changeset
  def <<(*statements); end
  def >>(*statements); end
  def append_statements(target, arg); end
  def apply(mutable, **options); end
  def count; end
  def delete!(*statements); end
  def delete(*statements); end
  def deletes; end
  def empty?; end
  def initialize(insert: nil, delete: nil, &block); end
  def insert!(*statements); end
  def insert(*statements); end
  def inserts; end
  def inspect!; end
  def inspect; end
  def mutable?; end
  def options; end
  def readable?; end
  def self.apply(mutable, **options, &block); end
  def writable?; end
  include RDF::Util::Coercions
end
class RDF::Query::Solution
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def __send(*arg0); end
  def bindings; end
  def bound?(name); end
  def compatible?(other); end
  def disjoint?(other); end
  def dup; end
  def each(&block); end
  def each_binding(&block); end
  def each_key(&block); end
  def each_name(&block); end
  def each_value(&block); end
  def each_variable; end
  def enum_binding; end
  def enum_for(method = nil); end
  def enum_name; end
  def enum_value; end
  def enum_variable; end
  def eql?(other); end
  def has_variables?(variables); end
  def hash; end
  def initialize(bindings = nil, &block); end
  def inspect; end
  def isomorphic_with?(other); end
  def merge!(other); end
  def merge(other); end
  def method_missing(name, *args, &block); end
  def respond_to_missing?(name, include_private = nil); end
  def to_a; end
  def to_enum(method = nil); end
  def to_h; end
  def unbound?(name); end
  include Enumerable
end
class RDF::Query::Solutions < Array
  def bindings; end
  def count(&block); end
  def distinct!; end
  def distinct; end
  def dup; end
  def each_solution; end
  def filter!(expression = nil, &block); end
  def filter(expression = nil, &block); end
  def has_variables?(variables); end
  def have_variables?(variables); end
  def limit!(length); end
  def limit(length); end
  def merge(other); end
  def minus(other); end
  def offset!(start); end
  def offset(start); end
  def order(*variables); end
  def order_by(*variables); end
  def project(*variables); end
  def reduced!; end
  def reduced; end
  def select(*variables); end
  def variable_names; end
end
class RDF::Query::HashPatternNormalizer
  def initialize(**options); end
  def normalize!(hash_pattern); end
  def options; end
  def self.ensure_absence_of_duplicate_subjects!(acc, subject); end
  def self.normalize!(*args); end
  def self.normalize_array!(array, *args); end
  def self.normalize_hash!(hash, *args); end
  def self.normalize_object!(object, *args); end
  def self.replace_hash_with_anonymous_subject!(hash, acc, counter, anonymous_subject_format); end
end
class RDF::Query::HashPatternNormalizer::Counter
  def decrement!; end
  def increment!; end
  def increment; end
  def initialize(offset = nil, increment = nil); end
  def offset; end
  def to_f; end
  def to_i; end
  def to_s; end
end
module RDF::Util::File
  def self.http_adapter(use_net_http = nil); end
  def self.http_adapter=(http_adapter); end
  def self.open_file(filename_or_url, proxy: nil, headers: nil, verify_none: nil, **options, &block); end
end
class RDF::Util::File::HttpAdapter
  def self.default_accept_header; end
  def self.default_user_agent; end
  def self.headers(headers: nil); end
  def self.open_url(base_uri, proxy: nil, headers: nil, verify_none: nil, **options); end
end
class RDF::Util::File::RestClientAdapter < RDF::Util::File::HttpAdapter
  def self.open_url(base_uri, proxy: nil, headers: nil, verify_none: nil, **options); end
end
class RDF::Util::File::NetHttpAdapter < RDF::Util::File::HttpAdapter
  def self.open_url(base_uri, proxy: nil, headers: nil, verify_none: nil, **options); end
end
class RDF::Util::File::FaradayAdapter < RDF::Util::File::HttpAdapter
  def self.conn; end
  def self.conn=(conn); end
  def self.open_url(base_uri, proxy: nil, headers: nil, verify_none: nil, **options); end
end
class RDF::Util::File::RemoteDocument < StringIO
  def base_uri; end
  def charset; end
  def code; end
  def content_encoding; end
  def content_type; end
  def etag; end
  def headers; end
  def initialize(body, options = nil); end
  def last_modified; end
  def links; end
  def parameters; end
  def requested_url; end
end
module RDF::Util::UUID
  def self.generate(format: nil); end
end
class RDF::XSD < RDF::Vocabulary
  def self.ENTITIES; end
  def self.ENTITY; end
  def self.ID; end
  def self.IDREF; end
  def self.IDREFS; end
  def self.NCName; end
  def self.NMTOKEN; end
  def self.NMTOKENS; end
  def self.NOTATION; end
  def self.Name; end
  def self.QName; end
  def self.anyAtomicType; end
  def self.anySimpleType; end
  def self.anyType; end
  def self.anyURI; end
  def self.base64Binary; end
  def self.boolean; end
  def self.byte; end
  def self.date; end
  def self.dateTime; end
  def self.dateTimeStamp; end
  def self.dayTimeDuration; end
  def self.decimal; end
  def self.double; end
  def self.duration; end
  def self.float; end
  def self.gDay; end
  def self.gMonth; end
  def self.gMonthDay; end
  def self.gYear; end
  def self.gYearMonth; end
  def self.hexBinary; end
  def self.int; end
  def self.integer; end
  def self.language; end
  def self.long; end
  def self.negativeInteger; end
  def self.new(*arg0); end
  def self.nonNegativeInteger; end
  def self.nonPositiveInteger; end
  def self.normalizedString; end
  def self.positiveInteger; end
  def self.short; end
  def self.string; end
  def self.time; end
  def self.token; end
  def self.unsignedByte; end
  def self.unsignedInt; end
  def self.unsignedLong; end
  def self.unsignedShort; end
  def self.yearMonthDuration; end
end
