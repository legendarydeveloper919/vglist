# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/hamster/all/hamster.rbi
#
# hamster-3.0.0

module Hamster
  def self.enumerate(enum); end
  def self.from(obj); end
  def self.interval(from, to); end
  def self.interval_exclusive(from, to); end
  def self.iterate(item, &block); end
  def self.repeat(item); end
  def self.replicate(number, item); end
  def self.stream(&block); end
  def self.to_ruby(obj); end
end
module Hamster::Undefined
end
module Hamster::Enumerable
  def <=>(other); end
  def ==(other); end
  def compact; end
  def delete_if; end
  def each_index(&block); end
  def grep(pattern, &block); end
  def grep_v(pattern, &block); end
  def group_by(&block); end
  def group_by_with(empty_group, &block); end
  def index(*arg0); end
  def inspect; end
  def join(separator = nil); end
  def partition; end
  def pretty_print(pp); end
  def product; end
  def reject; end
  def sum; end
  def to_ary(*arg0); end
  def to_set; end
  include Enumerable
end
module Hamster::Immutable
  def self.included(klass); end
end
module Hamster::Immutable::ClassMethods
  def memoize(*names); end
  def new(*args); end
end
module Hamster::Immutable::MemoizeMethods
  def immutable!; end
end
module Hamster::Immutable::InstanceMethods
  def __hamster_immutable_dup__; end
  def clone; end
  def dup; end
  def immutable!; end
  def immutable?; end
  def transform(&block); end
  def transform_unless(condition, &block); end
end
class Hamster::Trie
  def ==(other); end
  def at(index); end
  def bulk_delete(keys); end
  def bulk_put(key_value_pairs); end
  def copy_size(copy); end
  def delete(key); end
  def delete_at(index = nil); end
  def each(&block); end
  def empty?; end
  def eql?(other); end
  def find_and_delete(key); end
  def get(key); end
  def include?(key, value); end
  def index_for(key); end
  def initialize(significant_bits, size = nil, entries = nil, children = nil); end
  def key?(key); end
  def put!(key, value); end
  def put(key, value); end
  def reduce(memo); end
  def reverse_each(&block); end
  def select; end
  def self.[](pairs); end
  def size; end
end
class Hamster::SortedSet
  def &(other); end
  def +(other); end
  def -(other); end
  def <<(item); end
  def [](arg, length = nil); end
  def ^(other); end
  def above(item, &block); end
  def add(item); end
  def add?(item); end
  def at(index); end
  def below(item, &block); end
  def between(from, to, &block); end
  def classify(&block); end
  def clear; end
  def collect; end
  def delete(item); end
  def delete?(item); end
  def delete_at(index); end
  def derive_new_sorted_set(node); end
  def difference(other); end
  def disjoint?(other); end
  def drop(n); end
  def drop_while; end
  def each(&block); end
  def empty?; end
  def eql?(other); end
  def exclusion(other); end
  def fetch(index, default = nil); end
  def find_all; end
  def find_index(obj = nil, &block); end
  def first; end
  def from(item, &block); end
  def group(&block); end
  def hash; end
  def include?(item); end
  def index(obj = nil, &block); end
  def initialize(items = nil, &block); end
  def intersect?(other); end
  def intersection(other); end
  def keep_if; end
  def last; end
  def length; end
  def map; end
  def marshal_dump; end
  def marshal_load(array); end
  def max; end
  def member?(item); end
  def merge(other); end
  def min; end
  def proper_subset?(other); end
  def proper_superset?(other); end
  def reverse_each(&block); end
  def sample; end
  def select; end
  def self.[](*items); end
  def self.alloc(node); end
  def self.empty; end
  def size; end
  def slice(arg, length = nil); end
  def sort(&block); end
  def sort_by(&block); end
  def subsequence(from, length); end
  def subset?(other); end
  def subtract(other); end
  def superset?(other); end
  def take(n); end
  def take_while; end
  def union(other); end
  def up_to(item, &block); end
  def values_at(*indices); end
  def |(other); end
  extend Hamster::Immutable::ClassMethods
  include Hamster::Enumerable
  include Hamster::Immutable
  include Hamster::Immutable::InstanceMethods
end
class Hamster::SortedSet::AVLNode
  def at(index); end
  def balance; end
  def between(from, to); end
  def bulk_delete(items); end
  def bulk_insert(items); end
  def clear; end
  def delete(item); end
  def derive(item, left, right); end
  def direction(item); end
  def drop(n); end
  def each(&block); end
  def each_between(from, to, &block); end
  def each_greater(item, inclusive, &block); end
  def each_less(item, inclusive, &block); end
  def empty?; end
  def finish_removal(keep_item, left, right); end
  def from_items(items); end
  def height; end
  def include?(item); end
  def initialize(item, comparator, left, right); end
  def insert(item); end
  def item; end
  def keep_only(items); end
  def left; end
  def max; end
  def min; end
  def natural_order?; end
  def partition(items); end
  def prefix(item, inclusive); end
  def rebalance(left, right); end
  def rebalance_left(left, right); end
  def rebalance_right(left, right); end
  def reverse_each(&block); end
  def right; end
  def self.from_items(items, comparator, from = nil, to = nil); end
  def size; end
  def slice(from, length); end
  def suffix(item, inclusive); end
  def take(n); end
end
class Hamster::SortedSet::AVLNode::Empty
  def at(index); end
  def between(from, to); end
  def bulk_delete(items); end
  def bulk_insert(items); end
  def delete(item); end
  def drop(n); end
  def each; end
  def each_between(item, inclusive); end
  def each_greater(item, inclusive); end
  def each_less(item, inclusive); end
  def empty?; end
  def height; end
  def include?(item); end
  def initialize(comparator); end
  def insert(item); end
  def keep_only(items); end
  def left; end
  def max; end
  def min; end
  def natural_order?; end
  def prefix(item, inclusive); end
  def reverse_each; end
  def right; end
  def size; end
  def slice(from, length); end
  def suffix(item, inclusive); end
  def take(n); end
end
class Hamster::SortedSet::PlainAVLNode < Hamster::SortedSet::AVLNode
  def clear; end
  def derive(item, left, right); end
  def direction(item); end
  def from_items(items); end
  def height; end
  def initialize(item, left, right); end
  def item; end
  def left; end
  def natural_order?; end
  def right; end
  def self.from_items(items, from = nil, to = nil); end
  def size; end
end
class Hamster::SortedSet::PlainAVLNode::Empty < Hamster::SortedSet::AVLNode::Empty
  def bulk_insert(items); end
  def initialize; end
  def insert(item); end
  def natural_order?; end
end
class Hamster::Set
  def &(other); end
  def +(other); end
  def -(other); end
  def <(other); end
  def <<(item); end
  def <=(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def ^(other); end
  def add(item); end
  def add?(item); end
  def classify(&block); end
  def clear; end
  def collect; end
  def delete(item); end
  def delete?(item); end
  def difference(other); end
  def disjoint?(other); end
  def each; end
  def empty?; end
  def eql?(other); end
  def exclusion(other); end
  def find_all; end
  def first; end
  def flatten; end
  def group(&block); end
  def hash; end
  def include?(object); end
  def initialize(items = nil); end
  def intersect?(other); end
  def intersection(other); end
  def keep_if; end
  def length; end
  def map; end
  def marshal_dump; end
  def marshal_load(dictionary); end
  def member?(object); end
  def merge(other); end
  def new_trie(trie); end
  def proper_subset?(other); end
  def proper_superset?(other); end
  def reverse_each; end
  def sample; end
  def select; end
  def self.[](*items); end
  def self.alloc(trie = nil); end
  def self.empty; end
  def size; end
  def sort(&comparator); end
  def sort_by(&mapper); end
  def subset?(other); end
  def subtract(other); end
  def superset?(other); end
  def to_set; end
  def union(other); end
  def |(other); end
  extend Hamster::Immutable::ClassMethods
  include Hamster::Enumerable
  include Hamster::Immutable
  include Hamster::Immutable::InstanceMethods
end
module Hamster::Associable
  def dig(key, *rest); end
  def update_in(*key_path, &block); end
end
class Hamster::Vector
  def *(times); end
  def +(other); end
  def <<(item); end
  def [](arg, length = nil); end
  def add(item); end
  def assoc(obj); end
  def at(index); end
  def bsearch; end
  def clear; end
  def collect; end
  def combination(n); end
  def concat(other); end
  def delete(obj); end
  def delete_at(index); end
  def drop(n); end
  def drop_while; end
  def each(&block); end
  def empty?; end
  def eql?(other); end
  def fetch(index, default = nil); end
  def fill(object, index = nil, length = nil); end
  def find_all; end
  def first; end
  def flat_map; end
  def flatten(level = nil); end
  def flatten_node(node, bitshift, result); end
  def flatten_range(node, bitshift, from, to); end
  def flatten_suffix(node, bitshift, from, result); end
  def get(index); end
  def hash; end
  def initialize(items = nil); end
  def insert(index, *items); end
  def keep_if; end
  def last; end
  def leaf_node_for(node, bitshift, index); end
  def length; end
  def map; end
  def marshal_dump; end
  def marshal_load(array); end
  def permutation(n = nil); end
  def pop; end
  def product(*vectors); end
  def push(item); end
  def put(index, item = nil); end
  def rassoc(obj); end
  def repeated_combination(n); end
  def repeated_permutation(n = nil); end
  def replace_node_suffix(node, bitshift, from, suffix); end
  def replace_suffix(from, suffix); end
  def reverse; end
  def reverse_each(&block); end
  def reverse_traverse_depth_first(node, level, &block); end
  def rindex(obj = nil); end
  def rotate(count = nil); end
  def sample; end
  def select; end
  def self.[](*items); end
  def self.alloc(root, size, levels); end
  def self.empty; end
  def set(index, item = nil); end
  def shift; end
  def shuffle; end
  def size; end
  def slice(arg, length = nil); end
  def sort; end
  def sort_by; end
  def subsequence(from, length); end
  def take(n); end
  def take_while; end
  def to_a; end
  def to_ary; end
  def transpose; end
  def traverse_depth_first(node, level, &block); end
  def uniq(&block); end
  def unshift(object); end
  def update_leaf_node(node, bitshift, index, item); end
  def update_root(index, item); end
  def values_at(*indices); end
  def zip(*others); end
  extend Hamster::Immutable::ClassMethods
  include Hamster::Associable
  include Hamster::Enumerable
  include Hamster::Immutable
  include Hamster::Immutable::InstanceMethods
end
class Hamster::Hash
  def <(other); end
  def <=(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def [](key); end
  def assoc(obj); end
  def clear; end
  def collect; end
  def default_proc; end
  def delete(key); end
  def derive_new_hash(trie); end
  def detect; end
  def each(&block); end
  def each_key; end
  def each_pair(&block); end
  def each_value; end
  def empty?; end
  def eql?(other); end
  def except(*keys); end
  def fetch(key, default = nil); end
  def fetch_values(*wanted); end
  def find; end
  def find_all(&block); end
  def flatten(level = nil); end
  def get(key); end
  def has_key?(key); end
  def has_value?(value); end
  def hash; end
  def include?(key); end
  def initialize(pairs = nil, &block); end
  def inspect; end
  def invert; end
  def keep_if(&block); end
  def key(value); end
  def key?(key); end
  def keys; end
  def length; end
  def map; end
  def marshal_dump; end
  def marshal_load(dictionary); end
  def member?(key); end
  def merge(other); end
  def pretty_print(pp); end
  def put(key, value = nil); end
  def rassoc(obj); end
  def reverse_each(&block); end
  def sample; end
  def select(&block); end
  def self.[](pairs = nil); end
  def self.alloc(trie = nil, block = nil); end
  def self.empty; end
  def size; end
  def slice(*wanted); end
  def sort; end
  def sort_by; end
  def store(key, value); end
  def to_h; end
  def to_hash; end
  def to_proc; end
  def value?(value); end
  def values; end
  def values_at(*wanted); end
  extend Hamster::Immutable::ClassMethods
  include Hamster::Associable
  include Hamster::Enumerable
  include Hamster::Immutable
  include Hamster::Immutable::InstanceMethods
end
module Hamster::List
  def +(other); end
  def <<(item); end
  def [](arg, length = nil); end
  def _uniq(items, &block); end
  def add(item); end
  def append(other); end
  def at(index); end
  def break(&block); end
  def cached_size?; end
  def chunk(number); end
  def clear; end
  def clone; end
  def collect(&block); end
  def combination(n); end
  def concat(other); end
  def cons(item); end
  def cycle; end
  def delete(obj); end
  def delete_at(index); end
  def drop(number); end
  def drop_while(&block); end
  def dup; end
  def each; end
  def each_chunk(number, &block); end
  def each_slice(number, &block); end
  def eql?(other); end
  def fill(obj, index = nil, length = nil); end
  def find_all(&block); end
  def flat_map(&block); end
  def flatten; end
  def group(&block); end
  def group_by(&block); end
  def hash; end
  def indices(object = nil, i = nil, &block); end
  def init; end
  def inits; end
  def insert(index, *items); end
  def inspect; end
  def intersperse(sep); end
  def keep_if(&block); end
  def last; end
  def length; end
  def map(&block); end
  def merge(&comparator); end
  def merge_by(&transformer); end
  def method_missing(name, *args, &block); end
  def partition(&block); end
  def permutation(length = nil, &block); end
  def pop; end
  def pretty_print(pp); end
  def respond_to?(name, include_private = nil); end
  def reverse; end
  def rotate(count = nil); end
  def sample; end
  def select(&block); end
  def self.[](*items); end
  def self.empty; end
  def self.from_enum(items); end
  def size; end
  def slice(arg, length = nil); end
  def sort(&comparator); end
  def sort_by(&transformer); end
  def span(&block); end
  def split_at(number); end
  def subsequences(&block); end
  def tails; end
  def take(number); end
  def take_while(&block); end
  def to_list; end
  def transpose; end
  def union(other, items = nil); end
  def uniq(&block); end
  def zip(others); end
  def |(other, items = nil); end
  include Hamster::Enumerable
end
class Hamster::Cons
  def cached_size?; end
  def empty?; end
  def head; end
  def initialize(head, tail = nil); end
  def length; end
  def size; end
  def tail; end
  include Hamster::List
end
class Hamster::LazyList
  def cached_size?; end
  def empty?; end
  def first; end
  def head; end
  def initialize(&block); end
  def length; end
  def realize; end
  def size; end
  def tail; end
  include Hamster::List
end
class Hamster::Realizable
  def cached_size?; end
  def empty?; end
  def first; end
  def head; end
  def initialize; end
  def length; end
  def realized?; end
  def size; end
  def tail; end
  include Hamster::List
end
class Hamster::Partitioner
  def done?; end
  def initialize(list, block); end
  def left; end
  def next_item; end
  def right; end
end
class Hamster::Partitioned < Hamster::Realizable
  def initialize(partitioner, buffer, mutex); end
  def realize; end
end
class Hamster::Splitter
  def done?; end
  def initialize(list, block); end
  def left; end
  def next_item; end
  def right; end
end
class Hamster::Splitter::Left < Hamster::Realizable
  def initialize(splitter, buffer, mutex); end
  def realize; end
end
class Hamster::Splitter::Right < Hamster::Realizable
  def initialize(splitter, mutex); end
  def realize; end
end
module Hamster::EmptyList
  def self.cached_size?; end
  def self.empty?; end
  def self.first; end
  def self.head; end
  def self.length; end
  def self.size; end
  def self.tail; end
end
module Enumerable
  def to_list; end
end
class IO
  def to_list(sep = nil); end
end
class Hamster::Deque
  def ==(other); end
  def clear; end
  def dequeue; end
  def empty?; end
  def enqueue(item); end
  def entries; end
  def eql?(other); end
  def first; end
  def initialize(items = nil); end
  def inspect; end
  def last; end
  def length; end
  def marshal_dump; end
  def marshal_load(array); end
  def pop; end
  def pretty_print(pp); end
  def push(item); end
  def self.[](*items); end
  def self.alloc(front, rear); end
  def self.empty; end
  def shift; end
  def size; end
  def to_a; end
  def to_ary; end
  def to_list; end
  def unshift(item); end
  extend Hamster::Immutable::ClassMethods
  include Hamster::Immutable
  include Hamster::Immutable::InstanceMethods
end
module Hamster::ReadCopyUpdate
  def ==(other); end
  def eql?(other); end
  def initialize(content); end
  def inspect(*args, &block); end
  def method_missing(name, *args, &block); end
  def to_s(*args, &block); end
  def transform; end
  extend Forwardable
end
class Hamster::MutableHash
  def []=(key, value); end
  def delete(key); end
  def put(key, value = nil, &block); end
  def self.[](pairs = nil); end
  def store(key, value); end
  include Hamster::ReadCopyUpdate
end
class Struct
end
