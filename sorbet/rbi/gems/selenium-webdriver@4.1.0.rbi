# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `selenium-webdriver` gem.
# Please instead update this file by running `bin/tapioca gem selenium-webdriver`.

module Selenium; end

module Selenium::WebDriver
  class << self
    def for(*args); end
    def logger; end
    def root; end
  end
end

class Selenium::WebDriver::ActionBuilder
  include ::Selenium::WebDriver::KeyActions
  include ::Selenium::WebDriver::PointerActions

  def initialize(bridge, mouse, keyboard, async = T.unsafe(nil)); end

  def add_key_input(name); end
  def add_pointer_input(kind, name); end
  def clear_all_actions; end
  def devices; end
  def get_device(name); end
  def key_inputs; end
  def pause(device, duration = T.unsafe(nil)); end
  def pauses(device, number, duration = T.unsafe(nil)); end
  def perform; end
  def pointer_inputs; end
  def release_actions; end

  private

  def add_input(device); end
  def tick(*action_devices); end
end

class Selenium::WebDriver::Alert
  def initialize(bridge); end

  def accept; end
  def dismiss; end
  def send_keys(keys); end
  def text; end
end

module Selenium::WebDriver::Atoms
  private

  def execute_atom(function_name, *arguments); end
  def read_atom(function); end
end

module Selenium::WebDriver::Chrome
  class << self
    def driver_path; end
    def driver_path=(path); end
    def path; end
    def path=(path); end
  end
end

class Selenium::WebDriver::Chrome::Driver < ::Selenium::WebDriver::Driver
  def browser; end

  private

  def devtools_address; end
  def devtools_url; end
  def devtools_version; end
end

Selenium::WebDriver::Chrome::Driver::EXTENSIONS = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::Chrome::Features
  def available_log_types; end
  def cast_issue_message; end
  def cast_sink_to_use=(name); end
  def cast_sinks; end
  def commands(command); end
  def delete_network_conditions; end
  def launch_app(id); end
  def log(type); end
  def network_conditions; end
  def network_conditions=(conditions); end
  def send_command(command_params); end
  def set_permission(name, value); end
  def start_cast_tab_mirroring(name); end
  def stop_casting(name); end
end

Selenium::WebDriver::Chrome::Features::CHROME_COMMANDS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Chrome::Options < ::Selenium::WebDriver::Options
  def initialize(profile: T.unsafe(nil), **opts); end

  def add_argument(arg); end
  def add_emulation(**opts); end
  def add_encoded_extension(encoded); end
  def add_extension(path); end
  def add_preference(name, value); end
  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), use_running_app: T.unsafe(nil), activity: T.unsafe(nil)); end
  def extensions; end
  def extensions=(extensions); end
  def headless!; end
  def logging_prefs; end
  def logging_prefs=(_arg0); end
  def profile; end
  def profile=(_arg0); end

  private

  def binary_path; end
  def camelize?(key); end
  def enable_logging(browser_options); end
  def encode_extension(path); end
  def process_browser_options(browser_options); end
  def validate_extension(path); end
end

Selenium::WebDriver::Chrome::Options::BROWSER = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Chrome::Options::CAPABILITIES = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Chrome::Options::KEY = T.let(T.unsafe(nil), String)

class Selenium::WebDriver::Chrome::Profile
  include ::Selenium::WebDriver::ProfileHelper
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods

  def initialize(model = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def add_encoded_extension(encoded); end
  def add_extension(path); end
  def as_json(*_arg0); end
  def directory; end
  def layout_on_disk; end

  private

  def prefs; end
  def prefs_file_for(dir); end
  def read_model_prefs; end
  def write_prefs_to(dir); end
end

class Selenium::WebDriver::Chrome::Service < ::Selenium::WebDriver::Service
  private

  def extract_service_args(driver_opts); end
end

Selenium::WebDriver::Chrome::Service::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Chrome::Service::EXECUTABLE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Chrome::Service::MISSING_TEXT = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Chrome::Service::SHUTDOWN_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

class Selenium::WebDriver::DevTools
  def initialize(url:); end

  def callbacks; end
  def close; end
  def method_missing(method, *_args); end
  def send_cmd(method, **params); end

  private

  def attach_socket_listener; end
  def callback_thread(params); end
  def error_message(error); end
  def incoming_frame; end
  def next_id; end
  def process_frame(frame); end
  def process_handshake; end
  def respond_to_missing?(method, *_args); end
  def socket; end
  def start_session; end
  def wait; end
  def ws; end
end

class Selenium::WebDriver::DevTools::ConsoleEvent
  def initialize(type:, timestamp:, args:); end

  def args; end
  def args=(_arg0); end
  def timestamp; end
  def timestamp=(_arg0); end
  def type; end
  def type=(_arg0); end
end

class Selenium::WebDriver::DevTools::ExceptionEvent
  def initialize(description:, timestamp:, stacktrace:); end

  def description; end
  def description=(_arg0); end
  def stacktrace; end
  def stacktrace=(_arg0); end
  def timestamp; end
  def timestamp=(_arg0); end
end

class Selenium::WebDriver::DevTools::MutationEvent
  def initialize(element:, attribute_name:, current_value:, old_value:); end

  def attribute_name; end
  def attribute_name=(_arg0); end
  def current_value; end
  def current_value=(_arg0); end
  def element; end
  def element=(_arg0); end
  def old_value; end
  def old_value=(_arg0); end
end

class Selenium::WebDriver::DevTools::PinnedScript
  def initialize(script); end

  def callable; end
  def devtools_identifier; end
  def devtools_identifier=(_arg0); end
  def key; end
  def key=(_arg0); end
  def remove; end
  def script; end
  def script=(_arg0); end
  def to_json(*_arg0); end
end

Selenium::WebDriver::DevTools::RESPONSE_WAIT_INTERVAL = T.let(T.unsafe(nil), Float)
Selenium::WebDriver::DevTools::RESPONSE_WAIT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::DevTools::Request
  def initialize(id:, url:, method:, headers:, post_data:); end

  def ==(other); end
  def headers; end
  def headers=(_arg0); end
  def id; end
  def inspect; end
  def method; end
  def method=(_arg0); end
  def post_data; end
  def post_data=(_arg0); end
  def url; end
  def url=(_arg0); end

  class << self
    def from(id, params); end
  end
end

class Selenium::WebDriver::DevTools::Response
  def initialize(id:, code:, body:, headers:); end

  def ==(other); end
  def body; end
  def body=(_arg0); end
  def code; end
  def code=(_arg0); end
  def headers; end
  def headers=(_arg0); end
  def id; end
  def inspect; end

  class << self
    def from(id, encoded_body, params); end
  end
end

class Selenium::WebDriver::Dimension < ::Struct
  def height; end
  def height=(_); end
  def width; end
  def width=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Selenium::WebDriver::Driver
  include ::Selenium::WebDriver::SearchContext
  include ::Selenium::WebDriver::TakesScreenshot

  def initialize(bridge: T.unsafe(nil), listener: T.unsafe(nil), **opts); end

  def [](sel); end
  def action; end
  def all(*args); end
  def browser; end
  def capabilities; end
  def close; end
  def current_url; end
  def execute_async_script(script, *args); end
  def execute_script(script, *args); end
  def first(*args); end
  def get(url); end
  def inspect; end
  def keyboard; end
  def manage; end
  def mouse; end
  def navigate; end
  def page_source; end
  def quit; end
  def ref; end
  def script(script, *args); end
  def status; end
  def switch_to; end
  def title; end
  def window_handle; end
  def window_handles; end

  private

  def add_extensions(browser); end
  def bridge; end
  def create_bridge(**opts); end
  def generate_capabilities(cap_array); end
  def screenshot; end
  def service_url(opts); end

  class << self
    def for(browser, opts = T.unsafe(nil)); end
  end
end

module Selenium::WebDriver::DriverExtensions; end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def download_path=(path); end
end

module Selenium::WebDriver::DriverExtensions::FullPageScreenshot
  def save_full_page_screenshot(path); end

  private

  def full_screenshot; end
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  def install_addon(path, temporary = T.unsafe(nil)); end
  def uninstall_addon(id); end
end

module Selenium::WebDriver::DriverExtensions::HasApplePermissions
  def permissions; end
  def permissions=(permissions); end
end

module Selenium::WebDriver::DriverExtensions::HasAuthentication
  def register(username:, password:, uri: T.unsafe(nil)); end

  private

  def auth_handlers; end
  def authenticate(request_id, url); end
end

module Selenium::WebDriver::DriverExtensions::HasCDP
  def execute_cdp(cmd, **params); end
end

module Selenium::WebDriver::DriverExtensions::HasCasting
  def cast_issue_message; end
  def cast_sink_to_use=(name); end
  def cast_sinks; end
  def start_cast_tab_mirroring(name); end
  def stop_casting(name); end
end

module Selenium::WebDriver::DriverExtensions::HasContext
  def context; end
  def context=(value); end
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  def attach_debugger; end
end

module Selenium::WebDriver::DriverExtensions::HasDevTools
  def devtools; end
end

module Selenium::WebDriver::DriverExtensions::HasLaunching
  def launch_app(id); end
end

module Selenium::WebDriver::DriverExtensions::HasLocation
  def location; end
  def location=(*_arg0); end
  def set_location; end
end

module Selenium::WebDriver::DriverExtensions::HasLogEvents
  include ::Selenium::WebDriver::Atoms

  def on_log_event(kind, &block); end

  private

  def log_console_events; end
  def log_exception_events; end
  def log_listeners; end
  def log_mutation_event(params); end
  def log_mutation_events; end
  def mutation_listener; end
end

Selenium::WebDriver::DriverExtensions::HasLogEvents::KINDS = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::DriverExtensions::HasLogs
  def logs; end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  def delete_network_conditions; end
  def network_conditions; end
  def network_conditions=(conditions); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
  def network_connection_type; end
  def network_connection_type=(*_arg0); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkInterception
  def intercept(&block); end

  private

  def fetch_response_body(id); end
  def intercept_request(id, params, &block); end
  def intercept_response(id, params); end
  def pending_response_requests; end
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  def add_permission(name, value); end
  def add_permissions(opt); end
end

module Selenium::WebDriver::DriverExtensions::HasPinnedScripts
  def pin_script(script); end
  def pinned_scripts; end
  def unpin_script(script); end
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  def remote_status; end
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  def session_id; end
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  def local_storage; end
  def session_storage; end
end

module Selenium::WebDriver::DriverExtensions::PrintsPage
  def print_page(**options); end
  def save_print_page(path, **options); end
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  def file_detector=(detector); end
end

module Selenium::WebDriver::Edge
  class << self
    def path; end
    def path=(path); end
  end
end

class Selenium::WebDriver::Edge::Driver < ::Selenium::WebDriver::Chrome::Driver
  def browser; end

  private

  def devtools_address; end
end

module Selenium::WebDriver::Edge::Features
  include ::Selenium::WebDriver::Chrome::Features

  def commands(command); end
end

Selenium::WebDriver::Edge::Features::EDGE_COMMANDS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Edge::Options < ::Selenium::WebDriver::Chrome::Options
  protected

  def enable_logging(browser_options); end

  private

  def binary_path; end
end

Selenium::WebDriver::Edge::Options::BROWSER = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Edge::Options::KEY = T.let(T.unsafe(nil), String)
class Selenium::WebDriver::Edge::Profile < ::Selenium::WebDriver::Chrome::Profile; end
class Selenium::WebDriver::Edge::Service < ::Selenium::WebDriver::Chrome::Service; end
Selenium::WebDriver::Edge::Service::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Edge::Service::EXECUTABLE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Edge::Service::MISSING_TEXT = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Edge::Service::SHUTDOWN_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

class Selenium::WebDriver::Element
  include ::Selenium::WebDriver::SearchContext
  include ::Selenium::WebDriver::TakesScreenshot

  def initialize(bridge, id); end

  def ==(other); end
  def [](name); end
  def accessible_name; end
  def all(*args); end
  def aria_role; end
  def as_json(*_arg0); end
  def attribute(name); end
  def clear; end
  def click; end
  def css_value(prop); end
  def displayed?; end
  def dom_attribute(name); end
  def enabled?; end
  def eql?(other); end
  def first(*args); end
  def hash; end
  def inspect; end
  def location; end
  def location_once_scrolled_into_view; end
  def property(name); end
  def rect; end
  def ref; end
  def selected?; end
  def send_key(*args); end
  def send_keys(*args); end
  def shadow_root; end
  def size; end
  def style(prop); end
  def submit; end
  def tag_name; end
  def text; end
  def to_json(*_arg0); end

  private

  def bridge; end
  def screenshot; end
  def selectable?; end
end

Selenium::WebDriver::Element::ELEMENT_KEY = T.let(T.unsafe(nil), String)

module Selenium::WebDriver::Error
  class << self
    def for_error(error); end
  end
end

class Selenium::WebDriver::Error::DetachedShadowRootError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::ElementClickInterceptedError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::ElementNotInteractableError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InsecureCertificateError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InvalidArgumentError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InvalidCookieDomainError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InvalidElementStateError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InvalidSelectorError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::InvalidSessionIdError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::JavascriptError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::MoveTargetOutOfBoundsError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchAlertError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchCookieError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchElementError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchFrameError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchShadowRootError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::NoSuchWindowError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::ScriptTimeoutError < ::Selenium::WebDriver::Error::WebDriverError; end

class Selenium::WebDriver::Error::ServerError < ::StandardError
  def initialize(response); end
end

class Selenium::WebDriver::Error::SessionNotCreatedError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::StaleElementReferenceError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::TimeoutError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnableToCaptureScreenError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnableToSetCookieError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnexpectedAlertOpenError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnknownCommandError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnknownError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnknownMethodError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::UnsupportedOperationError < ::Selenium::WebDriver::Error::WebDriverError; end
class Selenium::WebDriver::Error::WebDriverError < ::StandardError; end

module Selenium::WebDriver::FileReaper
  class << self
    def <<(file); end
    def reap(file); end
    def reap!; end
    def reap=(_arg0); end
    def reap?; end
    def tmp_files; end
  end
end

module Selenium::WebDriver::Firefox
  class << self
    def driver_path; end
    def driver_path=(path); end
    def path; end
    def path=(path); end
  end
end

Selenium::WebDriver::Firefox::DEFAULT_ASSUME_UNTRUSTED_ISSUER = T.let(T.unsafe(nil), TrueClass)
Selenium::WebDriver::Firefox::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Firefox::DEVTOOLS_VERSION = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::Firefox::Driver < ::Selenium::WebDriver::Driver
  def browser; end

  private

  def devtools_url; end
  def devtools_version; end
end

Selenium::WebDriver::Firefox::Driver::EXTENSIONS = T.let(T.unsafe(nil), Array)

class Selenium::WebDriver::Firefox::Extension
  def initialize(path); end

  def write_to(extensions_dir); end

  private

  def applications_gecko_id(manifest); end
  def create_root; end
  def name_and_version(manifest); end
  def read_id(directory); end
  def read_id_from_install_rdf(directory); end
  def read_id_from_manifest_json(directory); end
end

Selenium::WebDriver::Firefox::Extension::NAMESPACE = T.let(T.unsafe(nil), String)

module Selenium::WebDriver::Firefox::Features
  def commands(command); end
  def context; end
  def context=(context); end
  def full_screenshot; end
  def install_addon(path, temporary); end
  def uninstall_addon(id); end
end

Selenium::WebDriver::Firefox::Features::FIREFOX_COMMANDS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Firefox::Options < ::Selenium::WebDriver::Options
  def initialize(log_level: T.unsafe(nil), **opts); end

  def add_argument(arg); end
  def add_preference(name, value); end
  def debugger_address; end
  def debugger_address=(_arg0); end
  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), activity: T.unsafe(nil), intent_arguments: T.unsafe(nil)); end
  def headless!; end
  def log_level; end
  def log_level=(level); end
  def profile; end
  def profile=(profile); end

  private

  def camelize?(key); end
  def process_browser_options(browser_options); end
  def process_profile(profile); end
end

Selenium::WebDriver::Firefox::Options::BROWSER = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Firefox::Options::CAPABILITIES = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Firefox::Options::KEY = T.let(T.unsafe(nil), String)

class Selenium::WebDriver::Firefox::Profile
  include ::Selenium::WebDriver::ProfileHelper
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods

  def initialize(model = T.unsafe(nil)); end

  def []=(key, value); end
  def add_extension(path, name = T.unsafe(nil)); end
  def as_json; end
  def layout_on_disk; end
  def load_no_focus_lib=(_arg0); end
  def log_file; end
  def log_file=(file); end
  def name; end
  def port=(port); end
  def proxy=(proxy); end
  def secure_ssl=(_arg0); end

  private

  def delete_extensions_cache(directory); end
  def delete_lock_files(directory); end
  def extension_name_for(path); end
  def install_extensions(directory); end
  def read_model_prefs; end
  def read_user_prefs(path); end
  def set_manual_proxy_preference(key, value); end
  def stringified?(str); end
  def update_user_prefs_in(directory); end
  def write_prefs(prefs, path); end

  class << self
    def decoded(json); end
    def from_name(name); end
    def ini; end
  end
end

Selenium::WebDriver::Firefox::Profile::DEFAULT_PREFERENCES = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Firefox::Profile::VALID_PREFERENCE_TYPES = T.let(T.unsafe(nil), Array)

class Selenium::WebDriver::Firefox::ProfilesIni
  def initialize; end

  def [](name); end
  def refresh; end

  private

  def parse; end
  def path_for(name, is_relative, path); end
end

class Selenium::WebDriver::Firefox::Service < ::Selenium::WebDriver::Service
  private

  def extract_service_args(driver_opts); end
end

Selenium::WebDriver::Firefox::Service::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Firefox::Service::EXECUTABLE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Firefox::Service::MISSING_TEXT = T.let(T.unsafe(nil), String)
module Selenium::WebDriver::HTML5; end

class Selenium::WebDriver::HTML5::LocalStorage
  include ::Enumerable
  include ::Selenium::WebDriver::HTML5::SharedWebStorage

  def initialize(bridge); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def keys; end
  def size; end
end

class Selenium::WebDriver::HTML5::SessionStorage
  include ::Enumerable
  include ::Selenium::WebDriver::HTML5::SharedWebStorage

  def initialize(bridge); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def keys; end
  def size; end
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable

  def each; end
  def empty?; end
  def fetch(key); end
  def has_key?(key); end
  def key?(key); end
  def member?(key); end
end

module Selenium::WebDriver::IE
  class << self
    def driver_path; end
    def driver_path=(path); end
  end
end

class Selenium::WebDriver::IE::Driver < ::Selenium::WebDriver::Driver
  def browser; end
end

Selenium::WebDriver::IE::Driver::EXTENSIONS = T.let(T.unsafe(nil), Array)

class Selenium::WebDriver::IE::Options < ::Selenium::WebDriver::Options
  def initialize(**opts); end

  def add_argument(arg); end
  def args; end

  private

  def process_browser_options(browser_options); end
end

Selenium::WebDriver::IE::Options::BROWSER = T.let(T.unsafe(nil), String)
Selenium::WebDriver::IE::Options::CAPABILITIES = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::IE::Options::KEY = T.let(T.unsafe(nil), String)
Selenium::WebDriver::IE::Options::SCROLL_BOTTOM = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::IE::Options::SCROLL_TOP = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::IE::Service < ::Selenium::WebDriver::Service
  private

  def extract_service_args(driver_opts); end
end

Selenium::WebDriver::IE::Service::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::IE::Service::EXECUTABLE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::IE::Service::MISSING_TEXT = T.let(T.unsafe(nil), String)
Selenium::WebDriver::IE::Service::SHUTDOWN_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

module Selenium::WebDriver::Interactions
  class << self
    def key(name); end
    def none(name = T.unsafe(nil)); end
    def pointer(kind, **kwargs); end
  end
end

class Selenium::WebDriver::Interactions::InputDevice
  def initialize(name = T.unsafe(nil)); end

  def actions; end
  def add_action(action); end
  def clear_actions; end
  def create_pause(duration = T.unsafe(nil)); end
  def name; end
  def no_actions?; end
end

class Selenium::WebDriver::Interactions::Interaction
  def initialize(source); end

  def source; end
end

Selenium::WebDriver::Interactions::Interaction::PAUSE = T.let(T.unsafe(nil), Symbol)
Selenium::WebDriver::Interactions::KEY = T.let(T.unsafe(nil), Symbol)

class Selenium::WebDriver::Interactions::KeyInput < ::Selenium::WebDriver::Interactions::InputDevice
  def create_key_down(key); end
  def create_key_up(key); end
  def encode; end
  def type; end
end

Selenium::WebDriver::Interactions::KeyInput::SUBTYPES = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction < ::Selenium::WebDriver::Interactions::Interaction
  def initialize(source, type, key); end

  def assert_type(type); end
  def encode; end
  def type; end
end

Selenium::WebDriver::Interactions::NONE = T.let(T.unsafe(nil), Symbol)

class Selenium::WebDriver::Interactions::NoneInput < ::Selenium::WebDriver::Interactions::InputDevice
  def encode; end
  def type; end
end

Selenium::WebDriver::Interactions::POINTER = T.let(T.unsafe(nil), Symbol)

class Selenium::WebDriver::Interactions::Pause < ::Selenium::WebDriver::Interactions::Interaction
  def initialize(source, duration = T.unsafe(nil)); end

  def encode; end
  def type; end
end

class Selenium::WebDriver::Interactions::PointerCancel < ::Selenium::WebDriver::Interactions::Interaction
  def encode; end
  def type; end
end

class Selenium::WebDriver::Interactions::PointerInput < ::Selenium::WebDriver::Interactions::InputDevice
  def initialize(kind, name: T.unsafe(nil)); end

  def assert_kind(pointer); end
  def create_pointer_cancel; end
  def create_pointer_down(button); end
  def create_pointer_move(duration: T.unsafe(nil), x: T.unsafe(nil), y: T.unsafe(nil), element: T.unsafe(nil), origin: T.unsafe(nil)); end
  def create_pointer_up(button); end
  def encode; end
  def kind; end
  def type; end
end

Selenium::WebDriver::Interactions::PointerInput::KIND = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Interactions::PointerMove < ::Selenium::WebDriver::Interactions::Interaction
  def initialize(source, duration, x, y, element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def encode; end
  def type; end
end

Selenium::WebDriver::Interactions::PointerMove::ORIGINS = T.let(T.unsafe(nil), Array)
Selenium::WebDriver::Interactions::PointerMove::POINTER = T.let(T.unsafe(nil), Symbol)
Selenium::WebDriver::Interactions::PointerMove::VIEWPORT = T.let(T.unsafe(nil), Symbol)

class Selenium::WebDriver::Interactions::PointerPress < ::Selenium::WebDriver::Interactions::Interaction
  def initialize(source, direction, button); end

  def assert_button(button); end
  def assert_direction(direction); end
  def encode; end
  def type; end
end

Selenium::WebDriver::Interactions::PointerPress::BUTTONS = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Interactions::PointerPress::DIRECTIONS = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Interactions::SOURCE_TYPES = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::KeyActions
  def key_down(*args, device: T.unsafe(nil)); end
  def key_up(*args, device: T.unsafe(nil)); end
  def send_keys(*args, device: T.unsafe(nil)); end

  private

  def key_action(*args, action: T.unsafe(nil), device: T.unsafe(nil)); end
end

module Selenium::WebDriver::Keys
  class << self
    def [](key); end
    def encode(keys); end
    def encode_key(key); end
  end
end

Selenium::WebDriver::Keys::KEYS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Location < ::Struct
  def altitude; end
  def altitude=(_); end
  def latitude; end
  def latitude=(_); end
  def longitude; end
  def longitude=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Selenium::WebDriver::LogEntry
  def initialize(level, timestamp, message); end

  def as_json(*_arg0); end
  def level; end
  def message; end
  def time; end
  def timestamp; end
  def to_s; end
end

class Selenium::WebDriver::Logger
  extend ::Forwardable

  def initialize(progname = T.unsafe(nil)); end

  def close(*args, &block); end
  def debug(*args, &block); end
  def debug?(*args, &block); end
  def deprecate(old, new = T.unsafe(nil), id: T.unsafe(nil), reference: T.unsafe(nil), &block); end
  def error(*args, &block); end
  def error?(*args, &block); end
  def fatal(*args, &block); end
  def fatal?(*args, &block); end
  def ignore(id); end
  def info(*args, &block); end
  def info?(*args, &block); end
  def io; end
  def level(*args, &block); end
  def level=(*args, &block); end
  def output=(io); end
  def warn(message, id: T.unsafe(nil)); end
  def warn?(*args, &block); end

  private

  def create_logger(name); end
  def default_level; end
end

class Selenium::WebDriver::Logs
  def initialize(bridge); end

  def available_types; end
  def get(type); end
end

class Selenium::WebDriver::Manager
  def initialize(bridge); end

  def add_cookie(opts = T.unsafe(nil)); end
  def all_cookies; end
  def cookie_named(name); end
  def delete_all_cookies; end
  def delete_cookie(name); end
  def logs; end
  def new_window(type = T.unsafe(nil)); end
  def timeouts; end
  def window; end

  private

  def convert_cookie(cookie); end
  def datetime_at(int); end
  def seconds_from(obj); end
  def strip_port(str); end
end

Selenium::WebDriver::Manager::SECONDS_PER_DAY = T.let(T.unsafe(nil), Float)

class Selenium::WebDriver::Navigation
  def initialize(bridge); end

  def back; end
  def forward; end
  def refresh; end
  def to(url); end
end

class Selenium::WebDriver::Options
  def initialize(options: T.unsafe(nil), **opts); end

  def ==(other); end
  def add_option(name, value = T.unsafe(nil)); end
  def as_json(*_arg0); end
  def eql?(other); end
  def options; end
  def options=(_arg0); end

  private

  def camel_case(str); end
  def camelize?(_key); end
  def convert_json_key(key, camelize: T.unsafe(nil)); end
  def generate_as_json(value, camelize_keys: T.unsafe(nil)); end
  def process_browser_options(_browser_options); end
  def process_json_hash(value, camelize_keys); end
  def process_w3c_options(options); end
  def w3c?(key); end

  class << self
    def chrome(**opts); end
    def driver_path; end
    def edge(**opts); end
    def firefox(**opts); end
    def ie(**opts); end
    def internet_explorer(**opts); end
    def microsoftedge(**opts); end
    def safari(**opts); end
    def set_capabilities; end
  end
end

Selenium::WebDriver::Options::W3C_OPTIONS = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::Platform
  private

  def assert_executable(path); end
  def assert_file(path); end
  def bitsize; end
  def ci; end
  def cygwin?; end
  def cygwin_path(path, **opts); end
  def engine; end
  def exit_hook; end
  def find_binary(*binary_names); end
  def find_in_program_files(*binary_names); end
  def home; end
  def interfaces; end
  def ip; end
  def jruby?; end
  def linux?; end
  def localhost; end
  def mac?; end
  def make_writable(file); end
  def null_device; end
  def os; end
  def ruby_version; end
  def unix_path(path); end
  def windows?; end
  def windows_path(path); end
  def wrap_in_quotes_if_necessary(str); end
  def wsl?; end

  class << self
    def assert_executable(path); end
    def assert_file(path); end
    def bitsize; end
    def ci; end
    def cygwin?; end
    def cygwin_path(path, **opts); end
    def engine; end
    def exit_hook; end
    def find_binary(*binary_names); end
    def find_in_program_files(*binary_names); end
    def home; end
    def interfaces; end
    def ip; end
    def jruby?; end
    def linux?; end
    def localhost; end
    def mac?; end
    def make_writable(file); end
    def null_device; end
    def os; end
    def ruby_version; end
    def unix_path(path); end
    def windows?; end
    def windows_path(path); end
    def wrap_in_quotes_if_necessary(str); end
    def wsl?; end
  end
end

class Selenium::WebDriver::Point < ::Struct
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Selenium::WebDriver::PointerActions
  def click(element = T.unsafe(nil), device: T.unsafe(nil)); end
  def click_and_hold(element = T.unsafe(nil), device: T.unsafe(nil)); end
  def context_click(element = T.unsafe(nil), device: T.unsafe(nil)); end
  def default_move_duration; end
  def default_move_duration=(_arg0); end
  def double_click(element = T.unsafe(nil), device: T.unsafe(nil)); end
  def drag_and_drop(source, target, device: T.unsafe(nil)); end
  def drag_and_drop_by(source, right_by, down_by, device: T.unsafe(nil)); end
  def move_by(right_by, down_by, device: T.unsafe(nil)); end
  def move_to(element, right_by = T.unsafe(nil), down_by = T.unsafe(nil), device: T.unsafe(nil)); end
  def move_to_location(x, y, device: T.unsafe(nil)); end
  def pointer_down(button, device: T.unsafe(nil)); end
  def pointer_up(button, device: T.unsafe(nil)); end
  def release(device: T.unsafe(nil)); end

  private

  def button_action(button, action: T.unsafe(nil), device: T.unsafe(nil)); end
  def get_pointer(device = T.unsafe(nil)); end
end

class Selenium::WebDriver::PortProber
  class << self
    def above(port); end
    def free?(port); end
  end
end

Selenium::WebDriver::PortProber::IGNORED_ERRORS = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::ProfileHelper
  mixes_in_class_methods ::Selenium::WebDriver::ProfileHelper::ClassMethods

  def as_json(*_arg0); end
  def encoded; end
  def to_json(*_arg0); end

  private

  def create_tmp_copy(directory); end
  def verify_model(model); end

  class << self
    def decoded(json); end
    def included(base); end
  end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  def from_json(json); end
end

class Selenium::WebDriver::Proxy
  def initialize(opts = T.unsafe(nil)); end

  def ==(other); end
  def as_json(*_arg0); end
  def auto_detect; end
  def auto_detect=(bool); end
  def eql?(other); end
  def ftp; end
  def ftp=(value); end
  def http; end
  def http=(value); end
  def no_proxy; end
  def no_proxy=(value); end
  def pac; end
  def pac=(url); end
  def socks; end
  def socks=(value); end
  def socks_password; end
  def socks_password=(value); end
  def socks_username; end
  def socks_username=(value); end
  def socks_version; end
  def socks_version=(value); end
  def ssl; end
  def ssl=(value); end
  def to_json(*_arg0); end
  def type; end
  def type=(type); end

  class << self
    def json_create(data); end
  end
end

Selenium::WebDriver::Proxy::ALLOWED = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Proxy::TYPES = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Rectangle < ::Struct
  def height; end
  def height=(_); end
  def width; end
  def width=(_); end
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Selenium::WebDriver::Remote; end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms

  def initialize(url:, http_client: T.unsafe(nil)); end

  def accept_alert; end
  def action(async = T.unsafe(nil)); end
  def actions(async = T.unsafe(nil)); end
  def active_element; end
  def add_cookie(cookie); end
  def alert=(keys); end
  def alert_text; end
  def browser; end
  def capabilities; end
  def clear_element(element); end
  def clear_local_storage; end
  def clear_session_storage; end
  def click_element(element); end
  def close; end
  def cookie(name); end
  def cookies; end
  def create_session(capabilities); end
  def delete_all_cookies; end
  def delete_cookie(name); end
  def dismiss_alert; end
  def element_aria_label(element); end
  def element_aria_role(element); end
  def element_attribute(element, name); end
  def element_displayed?(element); end
  def element_dom_attribute(element, name); end
  def element_enabled?(element); end
  def element_location(element); end
  def element_location_once_scrolled_into_view(element); end
  def element_property(element, name); end
  def element_rect(element); end
  def element_screenshot(element); end
  def element_selected?(element); end
  def element_size(element); end
  def element_tag_name(element); end
  def element_text(element); end
  def element_value(element); end
  def element_value_of_css_property(element, prop); end
  def execute_async_script(script, *args); end
  def execute_script(script, *args); end
  def file_detector; end
  def file_detector=(_arg0); end
  def find_element_by(how, what, parent_ref = T.unsafe(nil)); end
  def find_elements_by(how, what, parent_ref = T.unsafe(nil)); end
  def full_screen_window; end
  def get(url); end
  def go_back; end
  def go_forward; end
  def http; end
  def http=(_arg0); end
  def keyboard; end
  def local_storage_item(key, value = T.unsafe(nil)); end
  def local_storage_keys; end
  def local_storage_size; end
  def manage; end
  def maximize_window(handle = T.unsafe(nil)); end
  def minimize_window; end
  def mouse; end
  def new_window(type); end
  def page_source; end
  def print_page(options = T.unsafe(nil)); end
  def quit; end
  def refresh; end
  def release_actions; end
  def remove_local_storage_item(key); end
  def remove_session_storage_item(key); end
  def reposition_window(x, y); end
  def resize_window(width, height, handle = T.unsafe(nil)); end
  def screenshot; end
  def send_actions(data); end
  def send_keys_to_element(element, keys); end
  def session_id; end
  def session_storage_item(key, value = T.unsafe(nil)); end
  def session_storage_keys; end
  def session_storage_size; end
  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end
  def shadow_root(element); end
  def status; end
  def submit_element(element); end
  def switch_to_active_element; end
  def switch_to_default_content; end
  def switch_to_frame(id); end
  def switch_to_parent_frame; end
  def switch_to_window(name); end
  def timeouts; end
  def timeouts=(timeouts); end
  def title; end
  def upload(local_file); end
  def url; end
  def window_handle; end
  def window_handles; end
  def window_position; end
  def window_rect; end
  def window_size(handle = T.unsafe(nil)); end

  private

  def commands(command); end
  def convert_locator(how, what); end
  def element_id_from(id); end
  def escape_css(string); end
  def escaper; end
  def execute(command, opts = T.unsafe(nil), command_hash = T.unsafe(nil)); end
  def prepare_capabilities_payload(capabilities); end
  def shadow_root_id_from(id); end
  def unwrap_script_result(arg); end
end

Selenium::WebDriver::Remote::Bridge::COMMANDS = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Remote::Bridge::ESCAPE_CSS_REGEXP = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Remote::Bridge::PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Remote::Bridge::QUIT_ERRORS = T.let(T.unsafe(nil), Array)
Selenium::WebDriver::Remote::Bridge::UNICODE_CODE_POINT = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::Remote::Capabilities
  def initialize(opts = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def accept_insecure_certs; end
  def accept_insecure_certs=(value); end
  def as_json(*_arg0); end
  def browser_name; end
  def browser_name=(value); end
  def browser_version; end
  def browser_version=(value); end
  def eql?(other); end
  def implicit_timeout; end
  def implicit_timeout=(timeout); end
  def merge!(other); end
  def page_load_strategy; end
  def page_load_strategy=(value); end
  def page_load_timeout; end
  def page_load_timeout=(timeout); end
  def platform; end
  def platform=(value); end
  def platform_name; end
  def platform_name=(value); end
  def proxy; end
  def proxy=(proxy); end
  def remote_session_id; end
  def remote_session_id=(value); end
  def script_timeout; end
  def script_timeout=(timeout); end
  def set_window_rect; end
  def set_window_rect=(value); end
  def strict_file_interactability; end
  def strict_file_interactability=(value); end
  def timeouts; end
  def timeouts=(timeouts); end
  def to_json(*_arg0); end
  def unhandled_prompt_behavior; end
  def unhandled_prompt_behavior=(value); end
  def version; end
  def version=(value); end
  def web_socket_url; end
  def web_socket_url=(value); end

  protected

  def capabilities; end

  private

  def convert_key(key); end
  def convert_value(key, value); end
  def process_capabilities(key, value, hash); end

  class << self
    def always_match(capabilities); end
    def camel_case(str_or_sym); end
    def chrome(opts = T.unsafe(nil)); end
    def edge(opts = T.unsafe(nil)); end
    def ff(opts = T.unsafe(nil)); end
    def firefox(opts = T.unsafe(nil)); end
    def first_match(*capabilities); end
    def htmlunit(opts = T.unsafe(nil)); end
    def ie(opts = T.unsafe(nil)); end
    def internet_explorer(opts = T.unsafe(nil)); end
    def json_create(data); end
    def microsoftedge(opts = T.unsafe(nil)); end
    def safari(opts = T.unsafe(nil)); end

    private

    def process_timeouts(caps, timeouts); end
  end
end

Selenium::WebDriver::Remote::Capabilities::KNOWN = T.let(T.unsafe(nil), Array)

class Selenium::WebDriver::Remote::Driver < ::Selenium::WebDriver::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::HasRemoteStatus

  def initialize(bridge: T.unsafe(nil), listener: T.unsafe(nil), **opts); end

  private

  def devtools_url; end
  def devtools_version; end
end

module Selenium::WebDriver::Remote::Http; end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end
  def close; end
  def quit_errors; end
  def server_url=(_arg0); end

  private

  def create_response(code, body, content_type); end
  def request(*_arg0); end
  def server_url; end
end

Selenium::WebDriver::Remote::Http::Common::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Remote::Http::Common::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)
Selenium::WebDriver::Remote::Http::Common::MAX_REDIRECTS = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::Remote::Http::Default < ::Selenium::WebDriver::Remote::Http::Common
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def close; end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def proxy=(_arg0); end
  def read_timeout; end
  def read_timeout=(_arg0); end

  private

  def http; end
  def new_http_client; end
  def new_request_for(verb, url, headers, payload); end
  def proxy; end
  def request(verb, url, headers, payload, redirects = T.unsafe(nil)); end
  def response_for(request); end
  def start(http); end
  def use_proxy?; end
end

Selenium::WebDriver::Remote::Http::Default::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::Remote::Response
  def initialize(code, payload = T.unsafe(nil)); end

  def [](key); end
  def code; end
  def error; end
  def payload; end

  private

  def add_backtrace(ex, server_trace); end
  def assert_ok; end
  def backtrace_from_remote(server_trace); end
  def process_error; end
end

module Selenium::WebDriver::Safari
  class << self
    def driver_path; end
    def driver_path=(path); end
    def path; end
    def path=(path); end
    def technology_preview; end
    def technology_preview!; end
    def technology_preview?; end
    def use_technology_preview; end
    def use_technology_preview=(_arg0); end
  end
end

class Selenium::WebDriver::Safari::Driver < ::Selenium::WebDriver::Driver
  def browser; end
end

Selenium::WebDriver::Safari::Driver::EXTENSIONS = T.let(T.unsafe(nil), Array)

module Selenium::WebDriver::Safari::Features
  def attach_debugger; end
  def commands(command); end
  def permissions; end
  def permissions=(permissions); end
end

Selenium::WebDriver::Safari::Features::SAFARI_COMMANDS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Safari::Options < ::Selenium::WebDriver::Options
  def add_option(name, value = T.unsafe(nil)); end
  def options; end
  def options=(_arg0); end
end

Selenium::WebDriver::Safari::Options::BROWSER = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Safari::Options::CAPABILITIES = T.let(T.unsafe(nil), Hash)
class Selenium::WebDriver::Safari::Service < ::Selenium::WebDriver::Service; end
Selenium::WebDriver::Safari::Service::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::Safari::Service::EXECUTABLE = T.let(T.unsafe(nil), String)
Selenium::WebDriver::Safari::Service::MISSING_TEXT = T.let(T.unsafe(nil), String)

module Selenium::WebDriver::SearchContext
  def find_element(*args); end
  def find_elements(*args); end

  private

  def extract_args(args); end
end

Selenium::WebDriver::SearchContext::FINDERS = T.let(T.unsafe(nil), Hash)

class Selenium::WebDriver::Service
  def initialize(path: T.unsafe(nil), port: T.unsafe(nil), args: T.unsafe(nil)); end

  def executable_path; end
  def extra_args; end
  def host; end
  def host=(_arg0); end
  def launch; end
  def port; end
  def shutdown_supported; end

  protected

  def extract_service_args(driver_opts); end

  private

  def binary_path(path = T.unsafe(nil)); end

  class << self
    def chrome(**opts); end
    def driver_path; end
    def driver_path=(path); end
    def edge(**opts); end
    def firefox(**opts); end
    def ie(**opts); end
    def internet_explorer(**opts); end
    def microsoftedge(**opts); end
    def safari(**opts); end
  end
end

class Selenium::WebDriver::ServiceManager
  def initialize(config); end

  def start; end
  def stop; end
  def uri; end

  private

  def build_process(*command); end
  def cannot_connect_error_text; end
  def connect_to_server; end
  def connect_until_stable; end
  def find_free_port; end
  def process_exited?; end
  def process_running?; end
  def socket_lock; end
  def start_process; end
  def stop_process; end
  def stop_server; end
end

Selenium::WebDriver::ServiceManager::SOCKET_LOCK_TIMEOUT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::ServiceManager::START_TIMEOUT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::ServiceManager::STOP_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::ShadowRoot
  include ::Selenium::WebDriver::SearchContext

  def initialize(bridge, id); end

  def ==(other); end
  def as_json(*_arg0); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def ref; end
  def to_json(*_arg0); end

  private

  def bridge; end
end

Selenium::WebDriver::ShadowRoot::ROOT_KEY = T.let(T.unsafe(nil), String)

class Selenium::WebDriver::SocketLock
  def initialize(port, timeout); end

  def locked; end

  private

  def can_lock?; end
  def current_time; end
  def did_lock?; end
  def lock; end
  def release; end
end

class Selenium::WebDriver::SocketPoller
  def initialize(host, port, timeout = T.unsafe(nil), interval = T.unsafe(nil)); end

  def closed?; end
  def connected?; end

  private

  def conn_completed?(sock); end
  def current_time; end
  def listening?; end
  def socket_writable?(sock); end
  def with_timeout; end
end

Selenium::WebDriver::SocketPoller::CONNECTED_ERRORS = T.let(T.unsafe(nil), Array)
Selenium::WebDriver::SocketPoller::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Selenium::WebDriver::SocketPoller::NOT_CONNECTED_ERRORS = T.let(T.unsafe(nil), Array)
module Selenium::WebDriver::Support; end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end
  def after_click(element, driver); end
  def after_close(driver); end
  def after_execute_script(script, driver); end
  def after_find(by, what, driver); end
  def after_navigate_back(driver); end
  def after_navigate_forward(driver); end
  def after_navigate_to(url, driver); end
  def after_quit(driver); end
  def before_change_value_of(element, driver); end
  def before_click(element, driver); end
  def before_close(driver); end
  def before_execute_script(script, driver); end
  def before_find(by, what, driver); end
  def before_navigate_back(driver); end
  def before_navigate_forward(driver); end
  def before_navigate_to(url, driver); end
  def before_quit(driver); end
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::Color
  def initialize(red, green, blue, alpha = T.unsafe(nil)); end

  def ==(other); end
  def alpha; end
  def blue; end
  def eql?(other); end
  def green; end
  def hash; end
  def hex; end
  def red; end
  def rgb; end
  def rgba; end

  class << self
    def from_hsl(h, s, l, a); end
    def from_string(str); end
    def hue_to_rgb(lum1, lum2, hue); end
  end
end

Selenium::WebDriver::Support::Color::HEX3_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::HEX_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::HSLA_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::HSL_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::RGBA_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::RGBA_PCT_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::RGB_PATTERN = T.let(T.unsafe(nil), Regexp)
Selenium::WebDriver::Support::Color::RGB_PCT_PATTERN = T.let(T.unsafe(nil), Regexp)

module Selenium::WebDriver::Support::Escaper
  class << self
    def escape(str); end
  end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def initialize(delegate, listener); end

  def clear_element(ref); end
  def click_element(ref); end
  def close; end
  def execute_script(script, *args); end
  def find_element_by(how, what, parent = T.unsafe(nil)); end
  def find_elements_by(how, what, parent = T.unsafe(nil)); end
  def get(url); end
  def go_back; end
  def go_forward; end
  def quit; end
  def send_keys_to_element(ref, keys); end

  private

  def create_element(ref); end
  def dispatch(name, *args); end
  def driver; end
  def method_missing(meth, *args, &blk); end
end

class Selenium::WebDriver::Support::RelativeLocator
  def initialize(locator); end

  def as_json; end
end

Selenium::WebDriver::Support::RelativeLocator::KEYS = T.let(T.unsafe(nil), Array)

class Selenium::WebDriver::Support::Select
  def initialize(element); end

  def deselect_all; end
  def deselect_by(how, what); end
  def first_selected_option; end
  def multiple?; end
  def options; end
  def select_all; end
  def select_by(how, what); end
  def selected_options; end

  private

  def deselect_by_index(index); end
  def deselect_by_text(text); end
  def deselect_by_value(value); end
  def deselect_option(option); end
  def deselect_options(opts); end
  def find_by_index(index); end
  def find_by_text(text); end
  def find_by_value(value); end
  def select_by_index(index); end
  def select_by_text(text); end
  def select_by_value(value); end
  def select_option(option); end
  def select_options(opts); end
end

module Selenium::WebDriver::TakesScreenshot
  def save_screenshot(png_path, full_page: T.unsafe(nil)); end
  def screenshot_as(format, full_page: T.unsafe(nil)); end
end

class Selenium::WebDriver::TargetLocator
  def initialize(bridge); end

  def active_element; end
  def alert; end
  def default_content; end
  def frame(id); end
  def new_window(type = T.unsafe(nil)); end
  def parent_frame; end
  def window(id); end
end

class Selenium::WebDriver::Timeouts
  def initialize(bridge); end

  def implicit_wait; end
  def implicit_wait=(seconds); end
  def page_load; end
  def page_load=(seconds); end
  def script; end
  def script=(seconds); end
  def script_timeout; end
  def script_timeout=(seconds); end
end

Selenium::WebDriver::VERSION = T.let(T.unsafe(nil), String)

class Selenium::WebDriver::Wait
  def initialize(opts = T.unsafe(nil)); end

  def until; end

  private

  def current_time; end
end

Selenium::WebDriver::Wait::DEFAULT_INTERVAL = T.let(T.unsafe(nil), Float)
Selenium::WebDriver::Wait::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Selenium::WebDriver::Window
  def initialize(bridge); end

  def full_screen; end
  def maximize; end
  def minimize; end
  def move_to(x, y); end
  def position; end
  def position=(point); end
  def rect; end
  def rect=(rectangle); end
  def resize_to(width, height); end
  def size; end
  def size=(dimension); end
end

module Selenium::WebDriver::Zipper
  class << self
    def unzip(path); end
    def zip(path); end
    def zip_file(path); end

    private

    def add_zip_entry(zip, file, entry_name); end
    def with_tmp_zip(&blk); end
  end
end

Selenium::WebDriver::Zipper::EXTENSIONS = T.let(T.unsafe(nil), Array)
