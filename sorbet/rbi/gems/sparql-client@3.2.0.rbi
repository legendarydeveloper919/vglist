# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sparql-client` gem.
# Please instead update this file by running `bin/tapioca gem sparql-client`.

module SPARQL
  private

  def first_content_type(acceptable, available); end
  def serialize_exception(exception, **options); end
  def serialize_results(solutions, **options); end

  class << self
    def execute(query, queryable, **options, &block); end
    def first_content_type(acceptable, available); end
    def parse(query, **options); end
    def serialize_exception(exception, **options); end
    def serialize_results(solutions, **options); end
  end
end

class SPARQL::Client
  def initialize(url, **options, &block); end

  def ask(*args, **options); end
  def call_query_method(meth, *args, **options); end
  def clear(what, *arguments); end
  def clear_graph(graph_uri, **options); end
  def close; end
  def construct(*args, **options); end
  def delete_data(data, **options); end
  def delete_insert(delete_graph, insert_graph = T.unsafe(nil), where_graph = T.unsafe(nil), **options); end
  def describe(*args, **options); end
  def headers; end
  def insert_data(data, **options); end
  def inspect; end
  def inspect!; end
  def nodes; end
  def options; end
  def parse_rdf_serialization(response, **options); end
  def parse_response(response, **options); end
  def query(query, **options); end
  def response(query, **options); end
  def select(*args, **options); end
  def update(query, **options); end
  def url; end

  protected

  def http_klass(scheme); end
  def make_get_request(query, headers = T.unsafe(nil)); end
  def make_post_request(query, headers = T.unsafe(nil)); end
  def request(query, headers = T.unsafe(nil), &block); end
  def request_method(query); end
  def set_url_default_graph(url); end

  class << self
    def finalize(klass); end
    def parse_csv_bindings(csv, nodes = T.unsafe(nil)); end
    def parse_json_bindings(json, nodes = T.unsafe(nil)); end
    def parse_json_value(value, nodes = T.unsafe(nil)); end
    def parse_tsv_bindings(tsv, nodes = T.unsafe(nil)); end
    def parse_xml_bindings(xml, nodes = T.unsafe(nil)); end
    def parse_xml_value(value, nodes = T.unsafe(nil)); end
    def serialize_patterns(patterns, use_vars = T.unsafe(nil)); end
    def serialize_predicate(value, rdepth = T.unsafe(nil)); end
    def serialize_uri(uri); end
    def serialize_value(value, use_vars = T.unsafe(nil)); end
  end
end

SPARQL::Client::ACCEPT_BRTR = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_CSV = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_GRAPH = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_JSON = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_RESULTS = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_TSV = T.let(T.unsafe(nil), Hash)
SPARQL::Client::ACCEPT_XML = T.let(T.unsafe(nil), Hash)
class SPARQL::Client::ClientError < ::StandardError; end
SPARQL::Client::DEFAULT_METHOD = T.let(T.unsafe(nil), Symbol)
SPARQL::Client::DEFAULT_PROTOCOL = T.let(T.unsafe(nil), Float)
SPARQL::Client::GRAPH_ALL = T.let(T.unsafe(nil), String)
class SPARQL::Client::MalformedQuery < ::SPARQL::Client::ClientError; end

class SPARQL::Client::Query < ::RDF::Query
  def initialize(form = T.unsafe(nil), **options, &block); end

  def asc(var); end
  def ask; end
  def build_patterns(patterns); end
  def construct(*patterns); end
  def desc(var); end
  def describe(*variables); end
  def distinct(state = T.unsafe(nil)); end
  def each_solution(&block); end
  def each_statement(&block); end
  def execute; end
  def expects_statements?; end
  def false?; end
  def filter(string); end
  def form; end
  def from(uri); end
  def graph(graph_uri_or_var); end
  def group(*variables); end
  def group_by(*variables); end
  def inspect; end
  def inspect!; end
  def limit(length); end
  def minus(*patterns, &block); end
  def offset(start); end
  def optional(*patterns, &block); end
  def options; end
  def order(*variables); end
  def order_by(*variables); end
  def prefix(val); end
  def reduced(state = T.unsafe(nil)); end
  def result; end
  def select(*variables); end
  def slice(start, length); end
  def solutions; end
  def to_s; end
  def to_s_ggp; end
  def true?; end
  def union(*patterns, &block); end
  def values(*args); end
  def where(*patterns_queries, &block); end
  def whether(*patterns_queries, &block); end

  class << self
    def ask(**options); end
    def construct(*patterns, **options); end
    def describe(*variables, **options); end
    def select(*variables, **options); end
  end
end

class SPARQL::Client::Query::Filter < ::SPARQL::Client::QueryElement
  def initialize(*args); end

  def to_s; end
end

class SPARQL::Client::Query::WhereDecorator < ::SimpleDelegator
  def select(*variables); end
end

class SPARQL::Client::QueryElement
  def initialize(*args); end

  def elements; end
  def to_s; end
end

SPARQL::Client::RESULT_ALL = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_BOOL = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_BRTR = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_CSV = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_JSON = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_TSV = T.let(T.unsafe(nil), String)
SPARQL::Client::RESULT_XML = T.let(T.unsafe(nil), String)

class SPARQL::Client::Repository < ::RDF::Repository
  def initialize(uri: T.unsafe(nil), **options, &block); end

  def clear_statements; end
  def client; end
  def count; end
  def delete(*statements); end
  def each(&block); end
  def each_object(&block); end
  def each_predicate(&block); end
  def each_statement(&block); end
  def each_subject(&block); end
  def empty?; end
  def has_object?(object); end
  def has_predicate?(predicate); end
  def has_statement?(statement); end
  def has_subject?(subject); end
  def has_triple?(triple); end
  def length; end
  def size; end
  def supports?(feature); end
  def update_client; end
  def writable?; end

  protected

  def delete_statements(statements); end
  def insert_statement(statement); end
  def insert_statements(statements); end
  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
end

class SPARQL::Client::ServerError < ::StandardError; end

module SPARQL::Client::Update
  class << self
    def clear(*arguments, **options); end
    def create(*arguments, **options); end
    def delete_data(*arguments, **options); end
    def drop(*arguments, **options); end
    def insert_data(*arguments, **options); end
    def load(*arguments, **options); end
  end
end

class SPARQL::Client::Update::Add < ::SPARQL::Client::Update::Operation
  def to_s; end
end

class SPARQL::Client::Update::Clear < ::SPARQL::Client::Update::Operation
  def all; end
  def default; end
  def expects_statements?; end
  def graph(uri); end
  def named; end
  def to_s; end
  def uri; end
end

class SPARQL::Client::Update::Copy < ::SPARQL::Client::Update::Operation
  def to_s; end
end

class SPARQL::Client::Update::Create < ::SPARQL::Client::Update::Operation
  def initialize(uri, **options); end

  def to_s; end
  def uri; end
end

class SPARQL::Client::Update::DeleteData < ::SPARQL::Client::Update::Operation
  def initialize(data, **options); end

  def data; end
  def graph(uri); end
  def to_s; end
end

class SPARQL::Client::Update::DeleteInsert < ::SPARQL::Client::Update::Operation
  def initialize(_delete_graph, _insert_graph = T.unsafe(nil), _where_graph = T.unsafe(nil), **options); end

  def delete_graph; end
  def graph(uri); end
  def insert_graph; end
  def to_s; end
  def where_graph; end
end

class SPARQL::Client::Update::Drop < ::SPARQL::Client::Update::Clear
  def to_s; end
end

class SPARQL::Client::Update::InsertData < ::SPARQL::Client::Update::Operation
  def initialize(data, **options); end

  def data; end
  def expects_statements?; end
  def graph(uri); end
  def to_s; end
end

class SPARQL::Client::Update::Load < ::SPARQL::Client::Update::Operation
  def initialize(from, into: T.unsafe(nil), **options); end

  def from; end
  def into(uri); end
  def to_s; end
end

class SPARQL::Client::Update::Move < ::SPARQL::Client::Update::Operation
  def to_s; end
end

class SPARQL::Client::Update::Operation
  def initialize(*arguments, **options); end

  def expects_statements?; end
  def options; end
  def silent; end
end

module SPARQL::Client::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

SPARQL::Client::VERSION::FILE = T.let(T.unsafe(nil), String)
SPARQL::Client::VERSION::MAJOR = T.let(T.unsafe(nil), String)
SPARQL::Client::VERSION::MINOR = T.let(T.unsafe(nil), String)
SPARQL::Client::VERSION::STRING = T.let(T.unsafe(nil), String)
SPARQL::Client::VERSION::TINY = T.let(T.unsafe(nil), String)
SPARQL::Client::XMLNS = T.let(T.unsafe(nil), Hash)
SPARQL::ERROR_MESSAGE = T.let(T.unsafe(nil), String)
